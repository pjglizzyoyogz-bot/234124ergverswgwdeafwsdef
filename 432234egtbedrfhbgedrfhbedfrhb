    script_key = "k8YJvEVlhJpesFPpTm5Bi4V6ccKYAwff"

    -- Single execution guard
    if getgenv then
        local g = getgenv()
        if g.__SNIPER_SCRIPT_LOADED then
            return -- already executed, prevent duplicate UI / requests
        end
        g.__SNIPER_SCRIPT_LOADED = true
    else
        -- Fallback global flag
        if _G.__SNIPER_SCRIPT_LOADED then return end
        _G.__SNIPER_SCRIPT_LOADED = true
    end

    local script_key = script_key or getgenv().script_key or _G.script_key

    -- Script Key Validation System
    local HttpService = game:GetService("HttpService")
    local function buildHttpRequest()
        local g = getgenv and getgenv() or _G
        -- Prefer the modern global `request` provided by most executors
        local candidates = {
            g and g.request,
            rawget(_G, "request"),
            g and g.http_request,
            rawget(_G, "http_request"),
            (syn and syn.request),
            (http and http.request),
            (fluxus and fluxus.request),
            rawget(_G, "httprequest")
        }
        for _, fn in ipairs(candidates) do
            if type(fn) == "function" then return fn end
        end
        return nil
    end

    local request = buildHttpRequest()

    -- IMPORTANT: Change this URL to your actual validation server URL when you deploy
    local VALIDATION_URL = "https://bot-i2ha.onrender.com/validate-key" 

    -- Function to get HWID
    local function getHWID()
        local hwid = gethwid and gethwid() or 
                    game:GetService("RbxAnalyticsService"):GetClientId() or
                    tostring(game:GetService("Players").LocalPlayer.UserId) .. "_" .. tostring(tick())
        return hwid
    end

    -- Function to validate script key by calling the validation server
    local function validateScriptKey(scriptKey)
        if not scriptKey or scriptKey == "" then
            -- Missing script key: exit silently without printing
            return false, "No script key provided."
        end

        if not request then
            -- HTTP request function not available; proceed without logging
            -- Fallback for environments without HTTP capabilities, though it's less secure.
            -- For now, we will just show a warning. In a real scenario, you might block execution.
            return true, "HTTP function not available." 
        end

        -- Adaptive real-time progress bar prior to final auth decision
        local hwid = getHWID()
        -- HWID logging removed for privacy

        local payload = { key = scriptKey, hwid = hwid }

        local done = false
        local requestOk, response, reqErr
        local startTick = tick()
        task.spawn(function()
            requestOk, response = pcall(function()
                return request({
                    Url = VALIDATION_URL,
                    Method = "POST",
                    Headers = { ["Content-Type"] = "application/json" },
                    Body = HttpService:JSONEncode(payload)
                })
            end)
            if not requestOk then
                reqErr = response
            elseif not response then
                reqErr = "No response object returned"
            end
            done = true
        end)

        -- GUI Loader Setup (Top of Screen)
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")
        local CoreGui = game:GetService("CoreGui")
        local player = Players.LocalPlayer

        -- Generate random 40-character name
        local function generateRandomGuiName()
            local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            local name = ""
            for i = 1, 40 do
                local randomIndex = math.random(1, #chars)
                name = name .. chars:sub(randomIndex, randomIndex)
            end
            return name
        end

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = generateRandomGuiName()
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.Parent = CoreGui

        -- Global UI scaling
        local UserInputService = game:GetService("UserInputService")
        local Camera = workspace.CurrentCamera
        local function computeAutoScale()
            -- Target baseline is 1080p height; scale uniformly with a small nudge on sub-1080p
            local vps = Camera and Camera.ViewportSize or Vector2.new(1920, 1080)
            local base = 1080
            local s = vps.Y / base
            -- Nudge down up to ~10% on smaller screens (720p..1080p) so UI is a bit smaller
            if vps.Y < 1080 then
                local t = math.clamp((vps.Y - 720) / (1080 - 720), 0, 1)
                local nudge = 0.9 + (0.1 * t) -- 720p -> 0.9x, 1080p -> 1.0x
                s = s * nudge
            end
            -- Slightly wider clamp to allow smaller min on small screens and avoid oversizing large displays
            if s < 0.6 then s = 0.6 elseif s > 1.2 then s = 1.2 end
            return s
        end
        -- Attach UIScale to main ScreenGui
    local rootScale = Instance.new("UIScale")
        rootScale.Name = "RootUIScale"
        rootScale.Parent = screenGui

        -- Settings-free auto scaling
        local function applyUiScale()
            local scale = computeAutoScale()
            rootScale.Scale = scale
            _G.__AJ_ROOT_SCALE = rootScale
        end
        -- Initial scale
        applyUiScale()
        -- expose applier for settings UI
        _G.__AJ_applyUiScale = applyUiScale
        -- React to viewport changes when auto scaling
        if Camera then
            Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
                applyUiScale()
            end)
        end

        local container = Instance.new("Frame")
        container.Name = "Container"
        container.Parent = screenGui
        container.AnchorPoint = Vector2.new(0.5, 0)
        -- start higher for slide-in
        container.Position = UDim2.new(0.5, 0, 0, -60)
        container.Size = UDim2.fromScale(0.3, 0) -- Scale-based width, fixed height
        container.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
        container.BorderSizePixel = 0
        container.BackgroundTransparency = 0.15
        
        -- Size constraints for loading notification
        local loadingSizeConstraint = Instance.new("UISizeConstraint")
        loadingSizeConstraint.MinSize = Vector2.new(350, 40)
        loadingSizeConstraint.MaxSize = Vector2.new(450, 40)
        loadingSizeConstraint.Parent = container

        local corner = Instance.new("UICorner", container)
        corner.CornerRadius = UDim.new(0, 10)

        local stroke = Instance.new("UIStroke", container)
        stroke.Thickness = 1
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        stroke.Color = Color3.fromRGB(90, 40, 50)
        stroke.Transparency = 0.25

        local padding = Instance.new("UIPadding", container)
        padding.PaddingTop = UDim.new(0, 6)
        padding.PaddingBottom = UDim.new(0, 6)
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)

        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Parent = container
        title.BackgroundTransparency = 1
        title.Position = UDim2.new(0, 0, 0, 1)
        title.Size = UDim2.new(0.5, -10, 0, 14)
        title.Font = Enum.Font.GothamMedium
        title.Text = "Authenticating Key"
        title.TextSize = 12
        title.TextColor3 = Color3.fromRGB(255, 150, 150)
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.TextScaled = false
        title.ZIndex = 2

        local sub = Instance.new("TextLabel")
        sub.Name = "Subtitle"
        sub.Parent = container
        sub.BackgroundTransparency = 1
        sub.AnchorPoint = Vector2.new(0.5, 0)
        -- Perfect horizontal center at top
        sub.Position = UDim2.new(0.5, 0, 0, 1)
        -- Moderate width so it doesn't fully overlap left title; adjust if needed
        sub.Size = UDim2.new(0.4, 0, 0, 14)
        sub.Font = Enum.Font.Gotham
        sub.Text = "Connecting..."
        sub.TextSize = 11
        sub.TextColor3 = Color3.fromRGB(200, 120, 120)
        sub.TextXAlignment = Enum.TextXAlignment.Center
        sub.TextScaled = false
        sub.ZIndex = 2

        local barHolder = Instance.new("Frame")
        barHolder.Name = "BarHolder"
        barHolder.Parent = container
        barHolder.AnchorPoint = Vector2.new(0.5, 1)
        barHolder.Position = UDim2.new(0.5, 0, 1, -6)
        barHolder.Size = UDim2.new(1, -24, 0, 6)
        barHolder.BackgroundColor3 = Color3.fromRGB(50, 20, 28)
        barHolder.BorderSizePixel = 0
        barHolder.BackgroundTransparency = 0.25
        barHolder.ZIndex = 1
        Instance.new("UICorner", barHolder).CornerRadius = UDim.new(0, 3)

        local fill = Instance.new("Frame")
        fill.Name = "Fill"
        fill.Parent = barHolder
        fill.BackgroundColor3 = Color3.fromRGB(200, 70, 70)
        fill.BorderSizePixel = 0
        fill.Size = UDim2.new(0, 0, 1, 0)
        fill.ZIndex = 1
        Instance.new("UICorner", fill).CornerRadius = UDim.new(0, 3)

        local glow = Instance.new("ImageLabel")
        glow.Name = "Glow"
        glow.Parent = fill
        glow.BackgroundTransparency = 1
        glow.Image = "rbxassetid://4996891970"
        glow.ImageColor3 = Color3.fromRGB(255, 120, 120)
        glow.Size = UDim2.new(1, 6, 1, 6)
        glow.Position = UDim2.new(0, -3, 0, -3)
        glow.ScaleType = Enum.ScaleType.Slice
        glow.SliceCenter = Rect.new(24, 24, 276, 276)
        glow.ImageTransparency = 0.4

        local pctLabel = Instance.new("TextLabel")
        pctLabel.Name = "Percent"
        pctLabel.Parent = container
        pctLabel.BackgroundTransparency = 1
        pctLabel.Visible = false -- hidden to avoid overlap; center text now primary

        -- Prepare for slide & fade in
        container.BackgroundTransparency = 1
        container.Visible = true
        local slideIn = TweenService:Create(container, TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, 0, 0, 6),
            BackgroundTransparency = 0.15
        })
        slideIn:Play()
        local slideInDone = false
        slideIn.Completed:Connect(function() slideInDone = true end)

        local lastPct = -1
        local function updateLoader(pct, phase)
            if pct < 0 then pct = 0 end
            if pct > 100 then pct = 100 end
            phase = phase or "" -- optional
            local elapsed = elapsed or nil
            if pct == lastPct and phase == "" then return end
            lastPct = pct
            pctLabel.Text = tostring(pct).."%"
            if phase ~= "" then
                if elapsed then
                    sub.Text = string.format("%s (%.2fs)", phase, elapsed)
                else
                    sub.Text = phase
                end
            end
            TweenService:Create(fill, TweenInfo.new(0.12, Enum.EasingStyle.Quad), {Size = UDim2.new(pct/100, 0, 1, 0)}):Play()
        end

        local function finalizeLoader(status, message, success, totalTimeSeconds)
            title.Text = success and "✓ Authenticated" or "Authentication Failed"
            if success then
                sub.Text = string.format("Finalizing (%.2fs)", totalTimeSeconds or 0)
            else
                sub.Text = message or status or ""
            end
            pctLabel.Text = "100%"

            local finalFill = success and Color3.fromRGB(235, 95, 95) or Color3.fromRGB(140, 30, 30)
            local finalGlow = success and Color3.fromRGB(255, 130, 130) or Color3.fromRGB(180, 60, 60)
            TweenService:Create(fill, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {BackgroundColor3 = finalFill}):Play()
            TweenService:Create(glow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {ImageColor3 = finalGlow, ImageTransparency = 0.18}):Play()

            task.delay(0.55, function()
                pcall(function()
                    local slideUp = TweenService:Create(container, TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
                        Position = UDim2.new(0.5, 0, 0, -60),
                        BackgroundTransparency = 1
                    })
                    slideUp:Play()
                    slideUp.Completed:Connect(function()
                        pcall(function() screenGui:Destroy() end)
                        if success and totalTimeSeconds then
                            -- Toast notification
                            local toast = Instance.new("ScreenGui")
                            toast.Name = generateRandomGuiName()
                            toast.IgnoreGuiInset = true
                            toast.ResetOnSpawn = false
                            toast.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                            toast.Parent = CoreGui

                            -- Scale toast consistently with main UI
                            local toastScale = Instance.new("UIScale")
                            toastScale.Name = "ToastUIScale"
                            toastScale.Scale = (rootScale and rootScale.Scale) or 1
                            toastScale.Parent = toast

                            local frame = Instance.new("Frame")
                            frame.Parent = toast
                            frame.AnchorPoint = Vector2.new(0.5, 0)
                            frame.Position = UDim2.new(0.5, 0, 0, -40)
                            frame.Size = UDim2.new(0, 250, 0, 30)
                            frame.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
                            frame.BorderSizePixel = 0
                            frame.BackgroundTransparency = 0.2
                            local fc = Instance.new("UICorner", frame) fc.CornerRadius = UDim.new(0, 8)
                            local fs = Instance.new("UIStroke", frame) fs.Thickness = 1 fs.Color = Color3.fromRGB(90,40,50) fs.Transparency = 0.25

                            local label = Instance.new("TextLabel")
                            label.Parent = frame
                            label.BackgroundTransparency = 1
                            label.Size = UDim2.new(1, -16, 1, 0)
                            label.Position = UDim2.new(0, 8, 0, 0)
                            label.Font = Enum.Font.GothamSemibold
                            label.TextSize = 13
                            label.TextColor3 = Color3.fromRGB(255, 150, 150)
                            label.TextXAlignment = Enum.TextXAlignment.Center
                            label.Text = string.format("Loaded SNIPER v1 in %.2fs", totalTimeSeconds)

                            -- slide in
                            TweenService:Create(frame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                                Position = UDim2.new(0.5, 0, 0, 10),
                                BackgroundTransparency = 0.12
                            }):Play()

                            -- hold then slide out
                            task.delay(2.2, function()
                                pcall(function()
                                    local out = TweenService:Create(frame, TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
                                        Position = UDim2.new(0.5, 0, 0, -50),
                                        BackgroundTransparency = 1
                                    })
                                    out:Play()
                                    out.Completed:Connect(function()
                                        pcall(function() toast:Destroy() end)
                                    end)
                                end)
                            end)
                        end
                    end)
                end)
            end)
        end

        -- Replace old print progress logic with GUI updates
        local MAX_TIME = 2.5
        local UPDATE_STEP = 0.05
        local lastPrinted = -1

        -- Drive progress until request finished or 95%
        -- Wait a brief moment so slide animation is visible
        local preStart = tick()
        while not slideInDone and (tick() - preStart) < 0.5 do task.wait() end

        while not done do
            local elapsed = tick() - startTick
            local target = math.min(95, math.floor((elapsed / MAX_TIME) * 95))
            updateLoader(target, "Connecting", elapsed)
            if done then break end
            if elapsed >= MAX_TIME then break end
            task.wait(UPDATE_STEP)
        end

        -- Wait (briefly) if still not done
        local safetyStart = tick()
        while not done and (tick() - safetyStart) < 5 do
            updateLoader(95, "Awaiting response")
            updateLoader(95, "Awaiting response", tick() - startTick)
            task.wait(0.15)
        end

        -- Finalize outcome
        if not done then
            -- Timed out contacting server
            updateLoader(100, "Timeout")
            local msg = "Validation server timeout. Try again later."
            print("[SNIPER]: [ AUTH ERROR ] - " .. msg)
            finalizeLoader("Timeout", msg, false)
            local lp = game:GetService('Players').LocalPlayer
            task.delay(0.25, function() pcall(function() lp:Kick("Whitelist Error\n" .. msg) end) end)
            return false, msg
        end

        local totalTime = tick() - startTick
        -- Smoothly advance from current to 100
        for pct = lastPrinted + 1, 100 do
            local elapsed = tick() - startTick
            local phase = (pct < 100) and "Processing" or "Verifying"
            updateLoader(pct, phase, elapsed)
            task.wait(0.008)
        end

        if not requestOk or not response then
            local errMsg = "Could not connect: " .. tostring(reqErr)
            updateLoader(100, "Connection Failed")
            print("[SNIPER]: [ AUTH ERROR ] - " .. errMsg)
            finalizeLoader("Error", errMsg, false)
            local lp = game:GetService('Players').LocalPlayer
            task.delay(0.25, function() pcall(function() lp:Kick("Whitelist Error\n" .. errMsg) end) end)
            return false, errMsg
        end

        if response.StatusCode == 200 then
            local responseBody = HttpService:JSONDecode(response.Body)
            updateLoader(100, "Finalizing")
            updateLoader(100, "Verifying", totalTime)
                finalizeLoader("Success", nil, true, totalTime)
            
            -- Wait for UI to complete animation
            task.wait(0.3)
            
            local expiry_message
            if responseBody.expires == "Never" then
                expiry_message = "Key Duration: Permanent"
            elseif responseBody.expiresAt then
                -- Basic date formatting from ISO string
                local year, month, day = responseBody.expiresAt:match("(%d%d%d%d)-(%d%d)-(%d%d)")
                expiry_message = "Key Expires On: " .. month .. "/" .. day .. "/" .. year
            else
                expiry_message = "Key expiry not set."
            end
            
        -- Key information logging removed for privacy

            return true, responseBody
        else
            local errorBody
            pcall(function() errorBody = HttpService:JSONDecode(response.Body) end)
            local errorMessage = (errorBody and errorBody.message) or response.Body or "Unknown validation error."

            -- Unified whitelist error kick formatting
            local Players = game:GetService("Players")
            local lp = Players.LocalPlayer
            local kickMsg = "Whitelist Error\nInvalid key. Make sure you use a VALID key or NOT USE it at all.\nReason: " .. errorMessage
            -- Attempt rconsole output styling
        updateLoader(100, "Invalid key")
        print("[SNIPER]: [ AUTH ERROR ] - Unable to authenticate.")
        finalizeLoader("Invalid", "Key rejected", false)
            task.delay(0.35, function()
                pcall(function()
                    lp:Kick(kickMsg)
                end)
            end)
            return false, errorMessage
        end
    end

    -- Validate script key before continuing
    if not script_key then return end

    local authStartTime = tick()
    local isValid, validationData = validateScriptKey(script_key)
    if not isValid then return end -- Kick already handled with message

    -- Validation succeeded - show success message
    local authDuration = string.format("%.2f", tick() - authStartTime)
    print("[SNIPER]: [ AUTH SUCCESS ] - Authenticated in " .. authDuration .. " seconds!")

    -- Execution tracking is now handled automatically by the validation server.
    -- No need for a separate /execute call.

    -- Rest of your original autojoiner code goes here...
    -- [The rest of the autojoiner.lua script content would be preserved]


    -- SNIPER v1 - Modern Dark UI
    local Players = game:GetService("Players")
    local TeleportService = game:GetService("TeleportService")
    local TweenService = game:GetService("TweenService")

    local player = Players.LocalPlayer
    local coreGui = game:GetService("CoreGui")

    -- Generate randomized GUI name
    local function generateRandomName()
        local chars = "abcdefghijklmnopqrstuvwxyz0123456789"
        local segments = {}
        
        for i = 1, 3 do
            local segment = ""
            local segmentLength = math.random(15, 25)
            for j = 1, segmentLength do
                local randomIndex = math.random(1, #chars)
                segment = segment .. chars:sub(randomIndex, randomIndex)
            end
            table.insert(segments, segment)
        end
        
        return table.concat(segments, "-")
    end

    -- Module Toggle Notification System
    local notificationActive = false -- Track if a notification is currently showing
    -- Helper: preemptively close any existing top-of-screen notifications
    local function closeActiveNotifications()
        local ok, CoreGui = pcall(function() return game:GetService("CoreGui") end)
        if not ok or not CoreGui then return end
        for _, gui in ipairs(CoreGui:GetChildren()) do
            if gui:IsA("ScreenGui") then
                local hasNotif = gui:FindFirstChild("NotificationFrame", true)
                if hasNotif then
                    pcall(function() gui:Destroy() end)
                end
            end
        end
        notificationActive = false
    end

    local function showModuleNotification(moduleName, enabled)
        -- Don't show notification if one is already active
        if notificationActive then
            return
        end
        
        notificationActive = true
        local notificationDuration = 2 -- seconds (reduced from 3)
        
        -- Create notification ScreenGui (matching initialization style)
        local notifGui = Instance.new("ScreenGui")
        notifGui.Name = generateRandomName()
        notifGui.IgnoreGuiInset = true
        notifGui.ResetOnSpawn = false
        notifGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        notifGui.Parent = coreGui
        
        -- Notification frame (centered at top like initialization)
        local notifFrame = Instance.new("Frame")
        notifFrame.Name = "NotificationFrame"
        notifFrame.AnchorPoint = Vector2.new(0.5, 0)
        notifFrame.Position = UDim2.new(0.5, 0, 0, -40) -- Start above screen
        notifFrame.Size = UDim2.fromScale(0.2, 0) -- Scale-based width
        notifFrame.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
        notifFrame.BorderSizePixel = 0
        notifFrame.BackgroundTransparency = 0.2
        notifFrame.Parent = notifGui
        
        -- Size constraints for notifications
        local notifSizeConstraint = Instance.new("UISizeConstraint")
        notifSizeConstraint.MinSize = Vector2.new(250, 45)
        notifSizeConstraint.MaxSize = Vector2.new(320, 45)
        notifSizeConstraint.Parent = notifFrame
        
        local notifCorner = Instance.new("UICorner")
        notifCorner.CornerRadius = UDim.new(0, 8)
        notifCorner.Parent = notifFrame
        
        local notifStroke = Instance.new("UIStroke")
        notifStroke.Thickness = 1
        notifStroke.Color = Color3.fromRGB(90, 40, 50)
        notifStroke.Transparency = 0.25
        notifStroke.Parent = notifFrame
        
        -- Title text: "Module Toggled"
        local titleText = Instance.new("TextLabel")
        titleText.Name = "TitleText"
        titleText.Size = UDim2.new(1, -16, 0, 14)
        titleText.Position = UDim2.new(0, 8, 0, 3)
        titleText.BackgroundTransparency = 1
        titleText.Font = Enum.Font.GothamSemibold
        titleText.TextSize = 12
        titleText.TextColor3 = Color3.fromRGB(255, 150, 150)
        titleText.TextXAlignment = Enum.TextXAlignment.Center
        titleText.TextYAlignment = Enum.TextYAlignment.Top
        titleText.Text = "Module Toggled"
        titleText.Parent = notifFrame
        
        -- Status text with RichText for colored parts
        local statusColor = (enabled == true) and "rgb(255, 182, 193)" or "rgb(255, 100, 100)" -- Pastel pink for enabled, red for disabled
        local statusText = (enabled == true) and "Enabled" or "Disabled"
        
        local notifText = Instance.new("TextLabel")
        notifText.Name = "NotifText"
        notifText.Size = UDim2.new(1, -16, 0, 16)
        notifText.Position = UDim2.new(0, 8, 0, 18)
        notifText.BackgroundTransparency = 1
        notifText.Font = Enum.Font.Gotham
        notifText.TextSize = 12
        notifText.TextColor3 = Color3.fromRGB(200, 200, 200)
        notifText.TextXAlignment = Enum.TextXAlignment.Center
        notifText.TextYAlignment = Enum.TextYAlignment.Top
        notifText.RichText = true
        notifText.Text = string.format('<font color="rgb(160, 160, 160)">%s</font> has been <font color="%s">%s</font>!', moduleName, statusColor, statusText)
        notifText.Parent = notifFrame
        
        -- Progress bar background
        local barBg = Instance.new("Frame")
        barBg.Name = "BarBackground"
        barBg.Size = UDim2.new(1, -16, 0, 2)
        barBg.Position = UDim2.new(0, 8, 1, -6)
        barBg.BackgroundColor3 = Color3.fromRGB(50, 20, 28)
        barBg.BorderSizePixel = 0
        barBg.BackgroundTransparency = 0.25
        barBg.Parent = notifFrame
        
        local barBgCorner = Instance.new("UICorner")
        barBgCorner.CornerRadius = UDim.new(0, 2)
        barBgCorner.Parent = barBg
        
        -- Progress bar fill
        local barFill = Instance.new("Frame")
        barFill.Name = "BarFill"
        barFill.Size = UDim2.new(1, 0, 1, 0)
        barFill.Position = UDim2.new(0, 0, 0, 0)
        barFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        barFill.BorderSizePixel = 0
        barFill.Parent = barBg
        
        local barFillCorner = Instance.new("UICorner")
        barFillCorner.CornerRadius = UDim.new(0, 2)
        barFillCorner.Parent = barFill
        
        -- Slide in animation (matching initialization)
        -- Scale notification ScreenGui with root scale
        local notifScale = Instance.new("UIScale")
        notifScale.Name = "NotifUIScale"
        notifScale.Scale = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
        notifScale.Parent = notifGui

        -- Sync notification scale with root scale
        if _G.__AJ_ROOT_SCALE then
            task.spawn(function()
                local last = notifScale.Scale
                while notifGui and notifGui.Parent do
                    local s = _G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale or last
                    if math.abs((s or 1) - (notifScale.Scale or 1)) > 1e-3 then
                        notifScale.Scale = s
                    end
                    task.wait(0.2)
                end
            end)
        end

        TweenService:Create(notifFrame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, 0, 0, 10),
            BackgroundTransparency = 0.12
        }):Play()
        
        -- Drain progress bar
        local drainTween = TweenService:Create(barFill, TweenInfo.new(notificationDuration, Enum.EasingStyle.Linear), {
            Size = UDim2.new(0, 0, 1, 0)
        })
        drainTween:Play()
        
        -- Hold then slide out (matching initialization timing)
        task.delay(notificationDuration + 0.2, function()
            pcall(function()
                local slideOut = TweenService:Create(notifFrame, TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
                    Position = UDim2.new(0.5, 0, 0, -50),
                    BackgroundTransparency = 1
                })
                slideOut:Play()
                slideOut.Completed:Connect(function()
                    pcall(function()
                        notifGui:Destroy()
                        notificationActive = false -- Mark notification as complete
                    end)
                end)
            end)
        end)
    end

    -- Slider Value Notification (Module Toggled style)
    local function showValueNotification(label, valueText)
        if notificationActive then return end
        notificationActive = true
        local notificationDuration = 2

        local notifGui = Instance.new("ScreenGui")
        notifGui.Name = generateRandomName()
        notifGui.IgnoreGuiInset = true
        notifGui.ResetOnSpawn = false
        notifGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        notifGui.Parent = coreGui

        local notifFrame = Instance.new("Frame")
        notifFrame.Name = "NotificationFrame"
        notifFrame.AnchorPoint = Vector2.new(0.5, 0)
        notifFrame.Position = UDim2.new(0.5, 0, 0, -40)
        notifFrame.Size = UDim2.new(0, 280, 0, 45)
        notifFrame.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
        notifFrame.BorderSizePixel = 0
        notifFrame.BackgroundTransparency = 0.2
        notifFrame.Parent = notifGui

        local notifCorner = Instance.new("UICorner")
        notifCorner.CornerRadius = UDim.new(0, 8)
        notifCorner.Parent = notifFrame

        local notifStroke = Instance.new("UIStroke")
        notifStroke.Thickness = 1
        notifStroke.Color = Color3.fromRGB(90, 40, 50)
        notifStroke.Transparency = 0.25
        notifStroke.Parent = notifFrame

        local titleText = Instance.new("TextLabel")
        titleText.Name = "TitleText"
        titleText.Size = UDim2.new(1, -16, 0, 14)
        titleText.Position = UDim2.new(0, 8, 0, 3)
        titleText.BackgroundTransparency = 1
        titleText.Font = Enum.Font.GothamSemibold
        titleText.TextSize = 12
        titleText.TextColor3 = Color3.fromRGB(255, 150, 150)
        titleText.TextXAlignment = Enum.TextXAlignment.Center
        titleText.TextYAlignment = Enum.TextYAlignment.Top
        titleText.Text = "Value Changed"
        titleText.Parent = notifFrame

        local notifText = Instance.new("TextLabel")
        notifText.Name = "NotifText"
        notifText.Size = UDim2.new(1, -16, 0, 16)
        notifText.Position = UDim2.new(0, 8, 0, 18)
        notifText.BackgroundTransparency = 1
        notifText.Font = Enum.Font.Gotham
        notifText.TextSize = 12
        notifText.TextColor3 = Color3.fromRGB(200, 200, 200)
        notifText.TextXAlignment = Enum.TextXAlignment.Center
        notifText.TextYAlignment = Enum.TextYAlignment.Top
        notifText.RichText = true
        notifText.Text = string.format('<font color="rgb(160, 160, 160)">%s</font> set to <font color="rgb(255, 182, 193)">%s</font>', tostring(label), tostring(valueText))
        notifText.Parent = notifFrame

        local barBg = Instance.new("Frame")
        barBg.Name = "BarBackground"
        barBg.Size = UDim2.new(1, -16, 0, 2)
        barBg.Position = UDim2.new(0, 8, 1, -6)
        barBg.BackgroundColor3 = Color3.fromRGB(50, 20, 28)
        barBg.BorderSizePixel = 0
        barBg.BackgroundTransparency = 0.25
        barBg.Parent = notifFrame

        local barBgCorner = Instance.new("UICorner")
        barBgCorner.CornerRadius = UDim.new(0, 2)
        barBgCorner.Parent = barBg

        local barFill = Instance.new("Frame")
        barFill.Name = "BarFill"
        barFill.Size = UDim2.new(1, 0, 1, 0)
        barFill.Position = UDim2.new(0, 0, 0, 0)
        barFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        barFill.BorderSizePixel = 0
        barFill.Parent = barBg

        local barFillCorner = Instance.new("UICorner")
        barFillCorner.CornerRadius = UDim.new(0, 2)
        barFillCorner.Parent = barFill

        -- Scale notification ScreenGui with root scale
        local notifScale = Instance.new("UIScale")
        notifScale.Name = "NotifUIScale"
        notifScale.Scale = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
        notifScale.Parent = notifGui

        -- Sync notification scale with root scale
        if _G.__AJ_ROOT_SCALE then
            task.spawn(function()
                local last = notifScale.Scale
                while notifGui and notifGui.Parent do
                    local s = _G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale or last
                    if math.abs((s or 1) - (notifScale.Scale or 1)) > 1e-3 then
                        notifScale.Scale = s
                    end
                    task.wait(0.2)
                end
            end)
        end

        TweenService:Create(notifFrame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, 0, 0, 10),
            BackgroundTransparency = 0.12
        }):Play()

        local drainTween = TweenService:Create(barFill, TweenInfo.new(notificationDuration, Enum.EasingStyle.Linear), {
            Size = UDim2.new(0, 0, 1, 0)
        })
        drainTween:Play()

        task.delay(notificationDuration + 0.2, function()
            pcall(function()
                local slideOut = TweenService:Create(notifFrame, TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
                    Position = UDim2.new(0.5, 0, 0, -50),
                    BackgroundTransparency = 1
                })
                slideOut:Play()
                slideOut.Completed:Connect(function()
                    pcall(function()
                        notifGui:Destroy()
                        notificationActive = false
                    end)
                end)
            end)
        end)
    end

    -- Found Server Notification (variant of the module toggle banner)
    local function showFoundServerNotification(brainrotName, moneyPerSecond)
        -- Found Server is high priority: preempt any active banner instead of skipping
        if notificationActive then closeActiveNotifications() end
        notificationActive = true
        local notificationDuration = 2

        local notifGui = Instance.new("ScreenGui")
        notifGui.Name = generateRandomName()
        notifGui.IgnoreGuiInset = true
        notifGui.ResetOnSpawn = false
        notifGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        notifGui.Parent = coreGui

        local notifFrame = Instance.new("Frame")
        notifFrame.Name = "NotificationFrame"
        notifFrame.AnchorPoint = Vector2.new(0.5, 0)
        notifFrame.Position = UDim2.new(0.5, 0, 0, -40)
        notifFrame.Size = UDim2.new(0, 300, 0, 45)
        notifFrame.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
        notifFrame.BorderSizePixel = 0
        notifFrame.BackgroundTransparency = 0.2
        notifFrame.Parent = notifGui

        local notifCorner = Instance.new("UICorner")
        notifCorner.CornerRadius = UDim.new(0, 8)
        notifCorner.Parent = notifFrame

        local notifStroke = Instance.new("UIStroke")
        notifStroke.Thickness = 1
        notifStroke.Color = Color3.fromRGB(90, 40, 50)
        notifStroke.Transparency = 0.25
        notifStroke.Parent = notifFrame

        local titleText = Instance.new("TextLabel")
        titleText.Name = "TitleText"
        titleText.Size = UDim2.new(1, -16, 0, 14)
        titleText.Position = UDim2.new(0, 8, 0, 3)
        titleText.BackgroundTransparency = 1
        titleText.Font = Enum.Font.GothamSemibold
        titleText.TextSize = 12
        titleText.TextColor3 = Color3.fromRGB(255, 150, 150)
        titleText.TextXAlignment = Enum.TextXAlignment.Center
        titleText.TextYAlignment = Enum.TextYAlignment.Top
        titleText.Text = "FOUND SERVER"
        titleText.Parent = notifFrame

        local info = string.format('<font color="rgb(160, 160, 160)">Joining</font> %s - %s', tostring(brainrotName or "Unknown"), tostring(moneyPerSecond or "Unknown"))
        local notifText = Instance.new("TextLabel")
        notifText.Name = "NotifText"
        notifText.Size = UDim2.new(1, -16, 0, 16)
        notifText.Position = UDim2.new(0, 8, 0, 18)
        notifText.BackgroundTransparency = 1
        notifText.Font = Enum.Font.Gotham
        notifText.TextSize = 12
        notifText.TextColor3 = Color3.fromRGB(200, 200, 200)
        notifText.TextXAlignment = Enum.TextXAlignment.Center
        notifText.TextYAlignment = Enum.TextYAlignment.Top
        notifText.RichText = true
        notifText.Text = info
        notifText.Parent = notifFrame

        local barBg = Instance.new("Frame")
        barBg.Name = "BarBackground"
        barBg.Size = UDim2.new(1, -16, 0, 2)
        barBg.Position = UDim2.new(0, 8, 1, -6)
        barBg.BackgroundColor3 = Color3.fromRGB(50, 20, 28)
        barBg.BorderSizePixel = 0
        barBg.BackgroundTransparency = 0.25
        barBg.Parent = notifFrame

        local barBgCorner = Instance.new("UICorner")
        barBgCorner.CornerRadius = UDim.new(0, 2)
        barBgCorner.Parent = barBg

        local barFill = Instance.new("Frame")
        barFill.Name = "BarFill"
        barFill.Size = UDim2.new(1, 0, 1, 0)
        barFill.Position = UDim2.new(0, 0, 0, 0)
        barFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        barFill.BorderSizePixel = 0
        barFill.Parent = barBg

        local barFillCorner = Instance.new("UICorner")
        barFillCorner.CornerRadius = UDim.new(0, 2)
        barFillCorner.Parent = barFill

        -- Scale notification ScreenGui with root scale
        local notifScale = Instance.new("UIScale")
        notifScale.Name = "NotifUIScale"
        notifScale.Scale = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
        notifScale.Parent = notifGui

        -- Sync notification scale with root scale
        if _G.__AJ_ROOT_SCALE then
            task.spawn(function()
                local last = notifScale.Scale
                while notifGui and notifGui.Parent do
                    local s = _G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale or last
                    if math.abs((s or 1) - (notifScale.Scale or 1)) > 1e-3 then
                        notifScale.Scale = s
                    end
                    task.wait(0.2)
                end
            end)
        end

        TweenService:Create(notifFrame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, 0, 0, 10),
            BackgroundTransparency = 0.12
        }):Play()

        local drainTween = TweenService:Create(barFill, TweenInfo.new(notificationDuration, Enum.EasingStyle.Linear), {
            Size = UDim2.new(0, 0, 1, 0)
        })
        drainTween:Play()

        task.delay(notificationDuration + 0.2, function()
            pcall(function()
                local slideOut = TweenService:Create(notifFrame, TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
                    Position = UDim2.new(0.5, 0, 0, -50),
                    BackgroundTransparency = 1
                })
                slideOut:Play()
                slideOut.Completed:Connect(function()
                    pcall(function()
                        notifGui:Destroy()
                        notificationActive = false
                    end)
                end)
            end)
        end)
    end

    -- Settings save/load system
    local HttpService = game:GetService("HttpService")
    -- Use the previously resolved `request` from buildHttpRequest(); do not redeclare here

    -- Relay (Render + Firebase) configuration
    local RELAY_BASE_URL = getgenv().BRAINROT_RELAY_URL or "https://rthregregergwr2342134-1.onrender.com"
    local RELAY_POLL_INTERVAL = tonumber(getgenv().BRAINROT_RELAY_POLL_INTERVAL) or 8

    -- Default settings (all off by default)
    local defaultSettings = {
        minMoney = 1.0,
        maxMoney = 9999.0,
        radarMinMoney = 0.0,
        radarMaxMoney = 9999.0,
        maxPlayers = 8,
        enabled = false,
        autoJoin = false, -- OFF by default
        radarActive = false, -- persist radar toggle
        listBeforeEnabled = false, -- show entries from past 3 minutes when turned on
    joinBefore30 = false, -- join items found within 30s before enabling autojoiner (default: false - only join NEW finds)
        colorTimersEnabled = false, -- color-code timers: green < 1min, yellow < 1:45, grey after
        ignoreUnknownPets = false,
        enableOnlyJoinList = false,
        onlyJoinList = "",
        ignoreList = "",
        whitelistList = "",
        -- Module settings
        blackBase = false,
        transparentBases = false,
        rainbowName = false,
        highlightHighest = false,
        time = false
    }

    -- Load saved settings
    local function loadSettings()
        local success, savedData = pcall(function()
            if readfile and isfile and isfile("autojoiner_config.json") then
                local data = readfile("autojoiner_config.json")
                return HttpService:JSONDecode(data)
            end
            return nil
        end)
        
        if success and savedData then
            -- Merge saved settings with defaults (in case new settings were added)
            for key, value in pairs(defaultSettings) do
                if savedData[key] == nil then
                    savedData[key] = value
                end
            end
            return savedData
        else
            return defaultSettings
        end
    end

    -- Save settings
    local function saveSettings(settingsToSave)
        pcall(function()
            if writefile then
                local jsonData = HttpService:JSONEncode(settingsToSave)
                writefile("autojoiner_config.json", jsonData)
            end
        end)
    end

    -- Load settings on startup
    local settings = loadSettings()
    -- Hard override: never start with autojoin enabled, even if saved in config
    settings.autoJoin = false
    settings.enabled = false

    -- Radar storage: array for iteration, map for O(1) lookups
    local radarData = {}
    local radarMap = {} -- uniqueKey -> radarData entry

    -- Create ScreenGui in CoreGui with randomized name
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = generateRandomName()
    screenGui.Parent = coreGui
    screenGui.ResetOnSpawn = false

    -- Main UI scale: follow root scale
    local mainScale = Instance.new("UIScale")
    mainScale.Name = "MainUIScale"
    mainScale.Scale = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
    mainScale.Parent = screenGui

    -- Listen for root scale changes if available
    if _G.__AJ_ROOT_SCALE then
        -- There is no direct change signal on UIScale.Scale; poll lightly to sync
        task.spawn(function()
            local last = mainScale.Scale
            while screenGui.Parent do
                local s = _G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale or last
                if math.abs((s or 1) - (mainScale.Scale or 1)) > 1e-3 then
                    mainScale.Scale = s
                end
                task.wait(0.2)
            end
        end)
    end

    -- Tooltip overlay ScreenGui (not scaled) so tooltips match mouse pixels
    local tooltipGui = Instance.new("ScreenGui")
    tooltipGui.Name = generateRandomName()
    tooltipGui.ResetOnSpawn = false
    tooltipGui.IgnoreGuiInset = true
    tooltipGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    tooltipGui.Parent = coreGui

    -- Tooltip system - sleek minimal strip
    local tooltipFrame = Instance.new("Frame")
    tooltipFrame.Name = "Tooltip"
    tooltipFrame.Size = UDim2.new(0, 200, 0, 22)
    tooltipFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    tooltipFrame.BorderSizePixel = 0
    tooltipFrame.ZIndex = 1000
    tooltipFrame.Visible = false
    tooltipFrame.BackgroundTransparency = 0.1
    tooltipFrame.Parent = tooltipGui

    local tooltipCorner = Instance.new("UICorner")
    tooltipCorner.CornerRadius = UDim.new(0, 4)
    tooltipCorner.Parent = tooltipFrame

    local tooltipStroke = Instance.new("UIStroke")
    tooltipStroke.Color = Color3.fromRGB(80, 80, 80)
    tooltipStroke.Thickness = 0.5
    tooltipStroke.Transparency = 0.5
    tooltipStroke.Parent = tooltipFrame

    local tooltipText = Instance.new("TextLabel")
    tooltipText.Size = UDim2.new(1, -12, 1, 0)
    tooltipText.Position = UDim2.new(0, 6, 0, 0)
    tooltipText.BackgroundTransparency = 1
    tooltipText.Text = ""
    tooltipText.TextColor3 = Color3.fromRGB(240, 240, 240)
    -- Baseline text size; overall tooltip scales via UIScale below
    tooltipText.TextSize = 10
    tooltipText.Font = Enum.Font.Gotham
    tooltipText.TextXAlignment = Enum.TextXAlignment.Left
    tooltipText.TextWrapped = true
    tooltipText.ZIndex = 1001
    tooltipText.Parent = tooltipFrame
    -- Scale tooltips with the root UI scale (keeps consistent size across screens)
    local tooltipUIScale = Instance.new("UIScale")
    tooltipUIScale.Name = "TooltipScale"
    tooltipUIScale.Scale = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
    tooltipUIScale.Parent = tooltipFrame
    -- Keep tooltip scale synced with root scale
    task.spawn(function()
        local last = tooltipUIScale.Scale
        while tooltipFrame.Parent do
            local s = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or last
            if math.abs((s or 1) - (tooltipUIScale.Scale or 1)) > 1e-3 then
                tooltipUIScale.Scale = s
            end
            task.wait(0.2)
        end
    end)

    -- Helper function to add tooltip to any UI element
    local function addTooltip(element, text)
        local connection1, connection2, connection3
        
        connection1 = element.MouseEnter:Connect(function()
            tooltipText.Text = text
            -- Resize tooltip based on text (sleeker sizing)
            local textBounds = game:GetService("TextService"):GetTextSize(
                tooltipText.Text,
                10,
                Enum.Font.Gotham,
                Vector2.new(250, 1000)
            )
            local finalWidth = math.min(textBounds.X + 12, 250)
            -- Use top-left anchoring for simpler positioning
            tooltipFrame.AnchorPoint = Vector2.new(0, 0)
            tooltipFrame.Size = UDim2.new(0, finalWidth, 0, 22)
            -- Position tooltip directly next to cursor (no scaling applied due to separate ScreenGui)
            local mouse = game.Players.LocalPlayer:GetMouse()
            -- bottom-right of cursor
            tooltipFrame.Position = UDim2.new(0, mouse.X + 12, 0, mouse.Y + 12)
            tooltipFrame.Visible = true
        end)
        
        connection2 = element.MouseLeave:Connect(function()
            tooltipFrame.Visible = false
            tooltipFrame.AnchorPoint = Vector2.new(0, 0)
        end)
        
        connection3 = element.MouseMoved:Connect(function(x, y)
            -- Update tooltip at bottom-right of cursor (top-left anchored)
            tooltipFrame.Position = UDim2.new(0, x + 12, 0, y + 12)
        end)
        
        return {connection1, connection2, connection3}
    end

    -- Helper function to add tooltip with dynamic text (function that returns text)
    local function addDynamicTooltip(element, textFunc)
        local connection1, connection2, connection3, updateLoop
        
        connection1 = element.MouseEnter:Connect(function()
            tooltipFrame.Visible = true
            -- Calculate initial size
            local mouse = game.Players.LocalPlayer:GetMouse()
            local initialText = textFunc()
            tooltipText.Text = initialText
            local textBounds = game:GetService("TextService"):GetTextSize(
                tooltipText.Text,
                10,
                Enum.Font.Gotham,
                Vector2.new(250, 1000)
            )
            local finalWidth = math.min(textBounds.X + 12, 250)
            tooltipFrame.AnchorPoint = Vector2.new(0, 0)
            tooltipFrame.Size = UDim2.new(0, finalWidth, 0, 22)
            -- bottom-right of cursor
            tooltipFrame.Position = UDim2.new(0, mouse.X + 12, 0, mouse.Y + 12)

            -- Start update loop for dynamic text
            updateLoop = task.spawn(function()
                while tooltipFrame.Visible do
                    local txt = textFunc()
                    tooltipText.Text = txt
                    local tBounds = game:GetService("TextService"):GetTextSize(
                        tooltipText.Text,
                        10,
                        Enum.Font.Gotham,
                        Vector2.new(250, 1000)
                    )
                    tooltipFrame.Size = UDim2.new(0, math.min(tBounds.X + 12, 250), 0, 22)
                    task.wait(0.1) -- Update 10 times per second
                end
            end)
        end)
        
        connection2 = element.MouseLeave:Connect(function()
            tooltipFrame.Visible = false
            tooltipFrame.AnchorPoint = Vector2.new(0, 0)
            if updateLoop then
                task.cancel(updateLoop)
                updateLoop = nil
            end
        end)
        
        connection3 = element.MouseMoved:Connect(function(x, y)
            tooltipFrame.Position = UDim2.new(0, x + 12, 0, y + 12)
        end)
        
        return {connection1, connection2, connection3}
    end

    -- Main Frame - Sleek dark design with resize capability
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromScale(0.35, 0.75) -- Smaller scale for big screens
    mainFrame.Position = UDim2.fromScale(0.5, 0.5) -- Center on screen
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5) -- Center anchor
    mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = false -- Disable default dragging, use custom
    mainFrame.Parent = screenGui
    -- Hide main UI by default; toggled via top bar button or T key
    mainFrame.Visible = false
    
    -- Add size constraints for mobile/desktop compatibility
    local sizeConstraint = Instance.new("UISizeConstraint")
    sizeConstraint.MinSize = Vector2.new(450, 550) -- Minimum size
    sizeConstraint.MaxSize = Vector2.new(650, 850) -- Reasonable max for big screens
    sizeConstraint.Parent = mainFrame
    
    -- Custom smooth dragging system
    local dragging = false
    local dragInput, dragStart, dragStartPos
    
    local function updateDrag(input)
        -- Convert screen pixel delta to unscaled GUI units so the cursor stays aligned while dragging
        local delta = input.Position - dragStart
        local s = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
        if s == 0 then s = 1 end
        local dx = delta.X / s
        local dy = delta.Y / s
        mainFrame.Position = UDim2.new(dragStartPos.X.Scale, dragStartPos.X.Offset + dx, dragStartPos.Y.Scale, dragStartPos.Y.Offset + dy)
    end

    -- Resize handle in bottom right corner (invisible but functional)
    local resizeHandle = Instance.new("Frame")
    resizeHandle.Name = "ResizeHandle"
    resizeHandle.Size = UDim2.new(0, 20, 0, 20) -- Touch-friendly size
    resizeHandle.Position = UDim2.new(1, -20, 1, -20)
    resizeHandle.BackgroundTransparency = 1 -- Invisible
    resizeHandle.BorderSizePixel = 0
    resizeHandle.Parent = mainFrame

    -- Resize functionality (scales from center, both sides)
    -- Make resize math UIScale-aware to avoid jumps/teleporting
    local resizing = false
    local startSize = nil -- scaled AbsoluteSize (for reference)
    local startPos = nil  -- raw screen-space mouse pos
    local resizeInput = nil
    local startFramePos = nil -- scaled AbsolutePosition (for reference)
    local resizeScale = 1 -- current root UIScale at resize start
    local startSizeUnscaled = nil -- size in unscaled GUI units
    local startFramePosUnscaled = nil -- top-left in unscaled GUI units

    resizeHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            resizing = true
            dragging = false -- Disable dragging while resizing
            resizeInput = input
            startSize = mainFrame.AbsoluteSize
            startPos = input.Position
            startFramePos = mainFrame.AbsolutePosition
            -- Capture scale and convert baselines to unscaled GUI units
            resizeScale = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
            if resizeScale == 0 then resizeScale = 1 end
            startSizeUnscaled = Vector2.new(startSize.X / resizeScale, startSize.Y / resizeScale)
            startFramePosUnscaled = Vector2.new(startFramePos.X / resizeScale, startFramePos.Y / resizeScale)
        end
    end)

    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            -- Map mouse delta from screen pixels to unscaled GUI units using resizeScale
            local rawDelta = input.Position - startPos
            local deltaUnscaledX = rawDelta.X / (resizeScale ~= 0 and resizeScale or 1)
            local deltaUnscaledY = rawDelta.Y / (resizeScale ~= 0 and resizeScale or 1)

            -- Small deadzone using screen pixels to prevent initial click jitter
            if math.abs(rawDelta.X) < 2 and math.abs(rawDelta.Y) < 2 then
                return
            end

            -- Use UISizeConstraint limits to avoid conflicts; these are in unscaled GUI units
            local s = (resizeScale ~= 0 and resizeScale or 1)
            local minW = (sizeConstraint and sizeConstraint.MinSize and sizeConstraint.MinSize.X) or 450
            local maxW = (sizeConstraint and sizeConstraint.MaxSize and sizeConstraint.MaxSize.X) or 650
            local minH = (sizeConstraint and sizeConstraint.MinSize and sizeConstraint.MinSize.Y) or 550
            local maxH = (sizeConstraint and sizeConstraint.MaxSize and sizeConstraint.MaxSize.Y) or 850

            -- Resize from bottom-right corner only (rounded to avoid subpixel jitter), in unscaled units
            local targetW = startSizeUnscaled.X + deltaUnscaledX
            local targetH = startSizeUnscaled.Y + deltaUnscaledY
            local newWidth = math.clamp(math.floor(targetW + 0.5), minW, maxW)
            local newHeight = math.clamp(math.floor(targetH + 0.5), minH, maxH)

            -- Compute new center so the top-left corner stays fixed (all in unscaled units)
            local startCenterX = startFramePosUnscaled.X + (startSizeUnscaled.X / 2)
            local startCenterY = startFramePosUnscaled.Y + (startSizeUnscaled.Y / 2)
            local widthDiff = newWidth - startSizeUnscaled.X
            local heightDiff = newHeight - startSizeUnscaled.Y
            local newCenterX = startCenterX + (widthDiff / 2)
            local newCenterY = startCenterY + (heightDiff / 2)

            -- Use parent absolute center and convert to unscaled for clean scale+offset
            local parent = mainFrame.Parent
            local parentCenterX = (parent.AbsolutePosition.X + (parent.AbsoluteSize.X / 2)) / s
            local parentCenterY = (parent.AbsolutePosition.Y + (parent.AbsoluteSize.Y / 2)) / s
            local offsetX = math.floor((newCenterX - parentCenterX) + 0.5)
            local offsetY = math.floor((newCenterY - parentCenterY) + 0.5)

            -- Apply size and position in unscaled offsets; UIScale will handle the visual scale
            mainFrame.Size = UDim2.fromOffset(newWidth, newHeight)
            mainFrame.Position = UDim2.new(0.5, offsetX, 0.5, offsetY)
        elseif dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateDrag(input)
        end
    end)

    game:GetService("UserInputService").InputEnded:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and input == resizeInput then
            resizing = false
            resizeInput = nil
            startSize = nil
            startPos = nil
            startFramePos = nil
            resizeScale = 1
            startSizeUnscaled = nil
            startFramePosUnscaled = nil
        end
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and input == dragInput then
            dragging = false
        end
    end)

    local mainFrameCorner = Instance.new("UICorner")
    mainFrameCorner.CornerRadius = UDim.new(0, 12)
    mainFrameCorner.Parent = mainFrame

    -- Subtle glow effect
    local glowStroke = Instance.new("UIStroke")
    glowStroke.Color = Color3.fromRGB(35, 35, 35)
    glowStroke.Thickness = 0.8 -- adjusted per request
    glowStroke.Transparency = 0.5
    glowStroke.Parent = mainFrame

    -- While dragging the window, make edges glow thin red
    do
        local UIS = game:GetService("UserInputService")
        local defaultColor = Color3.fromRGB(35, 35, 35)
        -- Match the Open Sniper button stroke color while dragging
        local dragColor = Color3.fromRGB(90, 40, 50)
        local isHeld = false

        local function setGlow(active)
            if active then
                glowStroke.Color = dragColor
                glowStroke.Transparency = 0.05
                glowStroke.Thickness = 0.8 -- ensure it's thin while dragging
            else
                glowStroke.Color = defaultColor
                glowStroke.Transparency = 0.5
                glowStroke.Thickness = 0.8
            end
        end

        -- Start glow on LMB down if frame is being dragged (avoids resize interaction)
        mainFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 and not resizing then
                isHeld = true
                setGlow(true)
            end
        end)

        -- Also support starting from title bar explicitly after it's created
        task.defer(function()
            if titleBar then
                titleBar.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 and not resizing then
                        isHeld = true
                        setGlow(true)
                    end
                end)
            end
        end)

        -- Turn off glow when releasing mouse anywhere
        UIS.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                if isHeld then
                    isHeld = false
                    setGlow(false)
                end
            end
        end)
    end

    -- Title Bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 45)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame

    local titleBarCorner = Instance.new("UICorner")
    titleBarCorner.CornerRadius = UDim.new(0, 12)
    titleBarCorner.Parent = titleBar

    -- Fix title bar bottom corners
    local titleBarFix = Instance.new("Frame")
    titleBarFix.Size = UDim2.new(1, 0, 0, 12)
    titleBarFix.Position = UDim2.new(0, 0, 1, -12)
    titleBarFix.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    titleBarFix.BorderSizePixel = 0
    titleBarFix.Parent = titleBar

    -- Title Text
    local titleText = Instance.new("TextLabel")
    titleText.Name = "TitleText"
    titleText.Size = UDim2.new(1, -90, 1, 0)
    titleText.Position = UDim2.new(0, 20, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = 'SNIPER v1 <font color="rgb(170,170,170)" size="12">| Premium</font>'
    titleText.RichText = true
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.TextSize = 16
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Font = Enum.Font.GothamBold
    titleText.Parent = titleBar
    
    -- Custom drag handlers for title bar
    titleBar.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not resizing then
            dragging = true
            dragInput = input
            dragStart = input.Position
            dragStartPos = mainFrame.Position
        end
    end)

    -- Add gradient to title text
    local titleGradient = Instance.new("UIGradient")
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 100, 100)), -- Red
        ColorSequenceKeypoint.new(1.0, Color3.fromRGB(255, 255, 255))  -- White
    }
    titleGradient.Rotation = 45
    titleGradient.Parent = titleText

    -- Minimize Button - Matches close button style
    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Name = "MinimizeButton"
    minimizeButton.Size = UDim2.new(0, 30, 0, 30)
    minimizeButton.Position = UDim2.new(1, -75, 0, 7.5)
    minimizeButton.BackgroundTransparency = 1
    minimizeButton.Text = "−"
    minimizeButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    minimizeButton.TextSize = 18
    minimizeButton.Font = Enum.Font.GothamBold
    minimizeButton.Parent = titleBar
    
    -- Add glow effect to minimize button (darker red, less intense)
    local minimizeGlow = Instance.new("UIStroke")
    minimizeGlow.Color = Color3.fromRGB(180, 60, 60)
    minimizeGlow.Thickness = 0
    minimizeGlow.Transparency = 0.65
    minimizeGlow.Parent = minimizeButton
    
    minimizeButton.MouseEnter:Connect(function()
        TweenService:Create(minimizeButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(255, 100, 100)
        }):Play()
        TweenService:Create(minimizeGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            Thickness = 1.2
        }):Play()
    end)
    
    minimizeButton.MouseLeave:Connect(function()
        TweenService:Create(minimizeButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(150, 150, 150)
        }):Play()
        TweenService:Create(minimizeGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            Thickness = 0
        }):Play()
    end)
    
    minimizeButton.MouseButton1Down:Connect(function()
        TweenService:Create(minimizeButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            TextSize = 16
        }):Play()
    end)
    
    minimizeButton.MouseButton1Up:Connect(function()
        TweenService:Create(minimizeButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            TextSize = 18
        }):Play()
    end)
    
    -- Will connect minimize button to toggle function after it's defined below

    -- Close Button - Enhanced with hover animation and glow
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 7.5)
    closeButton.BackgroundTransparency = 1
    closeButton.Text = "×"
    closeButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    closeButton.TextSize = 18
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = titleBar
    
    -- Add glow effect to close button (darker red, less intense)
    local closeGlow = Instance.new("UIStroke")
    closeGlow.Color = Color3.fromRGB(180, 60, 60)
    closeGlow.Thickness = 0
    closeGlow.Transparency = 0.65
    closeGlow.Parent = closeButton

    closeButton.MouseEnter:Connect(function()
        TweenService:Create(closeButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(255, 100, 100)
        }):Play()
        TweenService:Create(closeGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            Thickness = 1.2
        }):Play()
    end)

    closeButton.MouseLeave:Connect(function()
        TweenService:Create(closeButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(150, 150, 150)
        }):Play()
        TweenService:Create(closeGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            Thickness = 0
        }):Play()
    end)
    
    closeButton.MouseButton1Down:Connect(function()
        TweenService:Create(closeButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            TextSize = 16
        }):Play()
    end)
    
    closeButton.MouseButton1Up:Connect(function()
        TweenService:Create(closeButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            TextSize = 18
        }):Play()
    end)

    -- Store connections for cleanup
    local _activeConnections = {}

    closeButton.MouseButton1Click:Connect(function()
        -- Full unload routine
        pcall(function()
            if screenGui and screenGui.Parent then screenGui:Destroy() end
        end)
        -- Destroy auth loader GUI if still present
        for _, gui in ipairs(game:GetService("CoreGui"):GetChildren()) do
        if gui:IsA("ScreenGui") and (gui.Name == "SniperAuthLoader" or (gui:FindFirstChild("Container") and gui:FindFirstChild("Container"):FindFirstChild("Title") and gui:FindFirstChild("Container"):FindFirstChild("Subtitle"))) then
                pcall(function() gui:Destroy() end)
            end
        end
        -- Disconnect all active connections
        for _, conn in ipairs(_activeConnections) do
            pcall(function() conn:Disconnect() end)
        end
        -- Remove global loaded flag to allow re-run if desired
        if getgenv then
            pcall(function() getgenv().__SNIPER_SCRIPT_LOADED = nil end)
        else
            _G.__SNIPER_SCRIPT_LOADED = nil
        end
        return
    end)

    -- Tab Container
    local tabContainer = Instance.new("Frame")
    tabContainer.Name = "TabContainer"
    tabContainer.Size = UDim2.new(1, -40, 0, 35)
    tabContainer.Position = UDim2.new(0, 20, 0, 55)
    tabContainer.BackgroundTransparency = 1
    tabContainer.Parent = mainFrame

    -- Tab underline
    local tabUnderline = Instance.new("Frame")
    tabUnderline.Size = UDim2.new(1, 0, 0, 1)
    tabUnderline.Position = UDim2.new(0, 0, 1, 0)
    tabUnderline.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    tabUnderline.BorderSizePixel = 0
    tabUnderline.Parent = tabContainer

    -- Content Container - improved centering (adjusted for bottom bar)
    local contentContainer = Instance.new("Frame")
    contentContainer.Name = "ContentContainer"
    contentContainer.Size = UDim2.new(1, -60, 1, -190) -- reduced height to make room for bottom bar
    contentContainer.Position = UDim2.new(0, 30, 0, 100)
    contentContainer.BackgroundTransparency = 1
    contentContainer.Parent = mainFrame

    -- Bottom Status Bar Divider
    local bottomDivider = Instance.new("Frame")
    bottomDivider.Name = "BottomDivider"
    bottomDivider.Size = UDim2.new(1, -40, 0, 1)
    bottomDivider.Position = UDim2.new(0, 20, 1, -60)
    bottomDivider.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    bottomDivider.BorderSizePixel = 0
    bottomDivider.Parent = mainFrame

    -- Bottom Status Bar
    local bottomBar = Instance.new("Frame")
    bottomBar.Name = "BottomBar"
    bottomBar.Size = UDim2.new(1, -40, 0, 50)
    bottomBar.Position = UDim2.new(0, 20, 1, -55)
    bottomBar.BackgroundTransparency = 1
    bottomBar.Parent = mainFrame

    -- Discord Profile Picture (Circle)
    local profileFrame = Instance.new("Frame")
    profileFrame.Name = "ProfileFrame"
    profileFrame.Size = UDim2.new(0, 40, 0, 40)
    profileFrame.Position = UDim2.new(0, 5, 0, 5)
    profileFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    profileFrame.BorderSizePixel = 0
    profileFrame.Parent = bottomBar
    local profileCorner = Instance.new("UICorner", profileFrame)
    profileCorner.CornerRadius = UDim.new(1, 0) -- perfect circle

    -- Profile image placeholder (will be replaced with actual avatar)
    local profileImage = Instance.new("ImageLabel")
    profileImage.Name = "ProfileImage"
    profileImage.Size = UDim2.new(1, 0, 1, 0)
    profileImage.BackgroundTransparency = 1
    profileImage.Image = "" -- Will be set dynamically if Discord avatar URL available
    profileImage.Parent = profileFrame
    local profileImageCorner = Instance.new("UICorner", profileImage)
    profileImageCorner.CornerRadius = UDim.new(1, 0)

    -- User Info Section (Welcome message centered next to profile)
    local userInfoLabel = Instance.new("TextLabel")
    userInfoLabel.Name = "UserInfo"
    userInfoLabel.Size = UDim2.new(0, 200, 0, 40)
    userInfoLabel.Position = UDim2.new(0, 55, 0, 5)
    userInfoLabel.BackgroundTransparency = 1
    userInfoLabel.Font = Enum.Font.GothamMedium
    userInfoLabel.TextSize = 13
    userInfoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    userInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
    userInfoLabel.TextYAlignment = Enum.TextYAlignment.Center
    userInfoLabel.Text = "Loading user info..."
    userInfoLabel.AutomaticSize = Enum.AutomaticSize.X
    userInfoLabel.Parent = bottomBar
    
    -- Subtle text stroke for welcome message
    local userInfoStroke = Instance.new("UIStroke")
    userInfoStroke.Color = Color3.fromRGB(180, 180, 180)
    userInfoStroke.Thickness = 0.6
    userInfoStroke.Transparency = 1
    userInfoStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    userInfoStroke.Parent = userInfoLabel
    
    -- Invisible button for hover detection
    local userInfoButton = Instance.new("TextButton")
    userInfoButton.Size = UDim2.new(1, 0, 1, 0)
    userInfoButton.BackgroundTransparency = 1
    userInfoButton.Text = ""
    userInfoButton.Parent = userInfoLabel
    
    -- Hover animation for welcome message
    userInfoButton.MouseEnter:Connect(function()
        TweenService:Create(userInfoLabel, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()
        TweenService:Create(userInfoStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            Transparency = 0.75
        }):Play()
    end)
    
    userInfoButton.MouseLeave:Connect(function()
        TweenService:Create(userInfoLabel, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(200, 200, 200)
        }):Play()
        TweenService:Create(userInfoStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            Transparency = 1
        }):Play()
    end)

    -- Key Time Left Section (Right side)
    local timeLeftLabel = Instance.new("TextLabel")
    timeLeftLabel.Name = "TimeLeft"
    timeLeftLabel.Size = UDim2.new(0, 150, 0, 40)
    timeLeftLabel.Position = UDim2.new(1, -155, 0, 5)
    timeLeftLabel.BackgroundTransparency = 1
    timeLeftLabel.Font = Enum.Font.GothamBold
    timeLeftLabel.TextSize = 13
    timeLeftLabel.TextColor3 = Color3.fromRGB(100, 255, 100) -- default green
    timeLeftLabel.TextXAlignment = Enum.TextXAlignment.Right
    timeLeftLabel.TextYAlignment = Enum.TextYAlignment.Center
    timeLeftLabel.Text = "Loading..."
    timeLeftLabel.Parent = bottomBar

    -- Format time remaining into readable string
    local function formatTimeLeft(seconds)
        if seconds <= 0 then return "Expired" end
        local days = math.floor(seconds / 86400)
        local hours = math.floor((seconds % 86400) / 3600)
        local mins = math.floor((seconds % 3600) / 60)
        local secs = math.floor(seconds % 60)
        
        if days > 0 then
            return string.format("%dd %dh %dm", days, hours, mins)
        elseif hours > 0 then
            return string.format("%dh %dm %ds", hours, mins, secs)
        elseif mins > 0 then
            return string.format("%dm %ds", mins, secs)
        else
            return string.format("%ds", secs)
        end
    end

    -- Update bottom bar with validation data
    if validationData then
        -- Set user welcome message with Roblox username
        local userId = validationData.userId or player.UserId
        local robloxUsername = player.Name
        
        -- Get executor name
        local executorName = "Unknown"
        if identifyexecutor then
            executorName = identifyexecutor() or "Unknown"
        end
        
        userInfoLabel.Text = string.format("Welcome, %s! | %s", robloxUsername, executorName)
        
        -- Add tooltip with full username and executor (one line)
        addDynamicTooltip(userInfoLabel, function()
            return "Logged in as: " .. robloxUsername .. " | Executor: " .. executorName
        end)
        
        -- Try to load Discord profile picture if avatar URL is provided
        if validationData.discordAvatarUrl and validationData.discordAvatarUrl ~= "" then
            profileImage.Image = validationData.discordAvatarUrl
        else
            -- Fallback: use Roblox avatar thumbnail
            local avatarUrl = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=%s&width=48&height=48&format=png", userId)
            profileImage.Image = avatarUrl
        end
        
        -- Calculate time left and set up countdown with periodic server sync
        local expiresAt = validationData.expiresAt
        local timeLeft = nil
        local expiryTimestamp = nil
        
        -- Parse ISO date helper
        local function parseISODate(isoString)
            if not isoString then return nil end
            local year, month, day, hour, min, sec = isoString:match("(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+)")
            if year then
                return os.time({year=year, month=month, day=day, hour=hour, min=min, sec=sec})
            end
            return nil
        end
        
        -- Function to refresh key data from server
        local function refreshKeyData()
            if not request then return end
            
            task.spawn(function()
                local hwid = getHWID()
                local payload = { key = script_key, hwid = hwid }
                
                local success, response = pcall(function()
                    return request({
                        Url = VALIDATION_URL,
                        Method = "POST",
                        Headers = { ["Content-Type"] = "application/json" },
                        Body = HttpService:JSONEncode(payload)
                    })
                end)
                
                if success and response and response.StatusCode == 200 then
                    local newData = HttpService:JSONDecode(response.Body)
                    
                    -- Update expiry timestamp
                    if newData.expires == "Never" or not newData.expiresAt then
                        expiryTimestamp = nil
                        timeLeftLabel.Text = "Lifetime"
                        timeLeftLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                    else
                        expiryTimestamp = parseISODate(newData.expiresAt)
                    end
                end
            end)
        end
        
        if validationData.expires == "Never" or not expiresAt then
            timeLeftLabel.Text = "Lifetime"
            timeLeftLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        else
            expiryTimestamp = parseISODate(expiresAt)
            if expiryTimestamp then
                -- Live countdown using RunService
                local RunService = game:GetService("RunService")
                local lastSyncTime = tick()
                local SYNC_INTERVAL = 30 -- Re-check server every 30 seconds
                
                local countdownConnection = RunService.Heartbeat:Connect(function()
                    local currentTime = os.time()
                    
                    -- Periodic server sync to catch key extensions/changes
                    if tick() - lastSyncTime >= SYNC_INTERVAL then
                        lastSyncTime = tick()
                        refreshKeyData()
                    end
                    
                    -- Only calculate countdown if we have a valid timestamp
                    if expiryTimestamp then
                        timeLeft = expiryTimestamp - currentTime
                        
                        if timeLeft <= 0 then
                            timeLeftLabel.Text = "Expired"
                            timeLeftLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                        else
                            local formatted = formatTimeLeft(timeLeft)
                            timeLeftLabel.Text = formatted
                            
                            -- Color coding
                            if timeLeft > 86400 then -- > 1 day
                                timeLeftLabel.TextColor3 = Color3.fromRGB(100, 255, 100) -- green
                            elseif timeLeft > 3600 then -- > 1 hour but < 1 day
                                timeLeftLabel.TextColor3 = Color3.fromRGB(255, 200, 50) -- yellow
                            else -- < 1 hour
                                timeLeftLabel.TextColor3 = Color3.fromRGB(255, 50, 50) -- red
                            end
                        end
                    end
                end)
                
                table.insert(_activeConnections, countdownConnection)
            end
        end
        
        -- Add tooltip for user info
        addTooltip(userInfoLabel, string.format("Welcome %s!", robloxUsername))
    end

    -- ===== AUTO-JOIN TOGGLE BAR (Top Middle - Initialization UI Style) =====
    local toggleBarContainer = Instance.new("Frame")
    toggleBarContainer.Name = "ToggleBarContainer"
    toggleBarContainer.AnchorPoint = Vector2.new(0.5, 0)
    -- Shift slightly left to make space for the Sniper toggle
    toggleBarContainer.Position = UDim2.new(0.5, -120, 0, 15)
    toggleBarContainer.Size = UDim2.new(0,190, 0, 35)
    toggleBarContainer.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
    toggleBarContainer.BorderSizePixel = 0
    toggleBarContainer.BackgroundTransparency = 0.15
    toggleBarContainer.Parent = screenGui

    local toggleCorner = Instance.new("UICorner", toggleBarContainer)
    toggleCorner.CornerRadius = UDim.new(0, 10)

    local toggleStroke = Instance.new("UIStroke", toggleBarContainer)
    toggleStroke.Thickness = 1
    toggleStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    toggleStroke.Color = Color3.fromRGB(90, 40, 50)
    toggleStroke.Transparency = 0.25

    local togglePadding = Instance.new("UIPadding", toggleBarContainer)
    togglePadding.PaddingTop = UDim.new(0, 8)
    togglePadding.PaddingBottom = UDim.new(0, 8)
    togglePadding.PaddingLeft = UDim.new(0, 12)
    togglePadding.PaddingRight = UDim.new(0, 12)

    local toggleTitle = Instance.new("TextLabel")
    toggleTitle.Name = "Title"
    toggleTitle.Parent = toggleBarContainer
    toggleTitle.BackgroundTransparency = 1
    toggleTitle.Position = UDim2.new(0, 0, 0, 0)
    toggleTitle.Size = UDim2.new(0.5, -10, 1, 0)
    toggleTitle.Font = Enum.Font.GothamMedium
    toggleTitle.Text = "AUTO JOINER"
    toggleTitle.TextSize = 13
    toggleTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
    toggleTitle.TextXAlignment = Enum.TextXAlignment.Left
    toggleTitle.TextYAlignment = Enum.TextYAlignment.Center
    toggleTitle.ZIndex = 2

    local toggleStatus = Instance.new("TextLabel")
    toggleStatus.Name = "Status"
    toggleStatus.Parent = toggleBarContainer
    toggleStatus.BackgroundTransparency = 1
    toggleStatus.AnchorPoint = Vector2.new(0.5, 0)
    toggleStatus.Position = UDim2.new(0.8, 0, 0, 0)
    toggleStatus.Size = UDim2.new(0.38, 0, 1, 0)
    toggleStatus.Font = Enum.Font.Gotham
    toggleStatus.Text = "Disabled"
    toggleStatus.TextSize = 12
    toggleStatus.TextColor3 = Color3.fromRGB(200, 120, 120)
    toggleStatus.TextXAlignment = Enum.TextXAlignment.Center
    toggleStatus.TextYAlignment = Enum.TextYAlignment.Center
    toggleStatus.ZIndex = 2

    -- Invisible button overlay
    local toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.Size = UDim2.new(1, 0, 1, 0)
    toggleButton.Position = UDim2.new(0, 0, 0, 0)
    toggleButton.BackgroundTransparency = 1
    toggleButton.Text = ""
    toggleButton.AutoButtonColor = false
    toggleButton.Parent = toggleBarContainer

    -- Update function
    local function updateToggleBar()
        if settings.autoJoin then
            toggleStatus.Text = "Active"
            toggleStatus.TextColor3 = Color3.fromRGB(255, 150, 150)
        else
            toggleStatus.Text = "Disabled"
            toggleStatus.TextColor3 = Color3.fromRGB(200, 120, 120)
        end
    end

    -- Initialize
    updateToggleBar()

    -- Add tooltip to AutoJoin toggle
    addTooltip(toggleBarContainer, "Toggle automatic joining when high-value brainrots are detected")

    -- Forward-declare shared setter so both UIs call the same logic
    local setAutoJoinEnabled

    -- Click handler
    toggleButton.MouseButton1Click:Connect(function()
        if setAutoJoinEnabled then
            setAutoJoinEnabled(not settings.autoJoin)
        else
            -- Fallback (shouldn't happen): just flip bar state
            settings.autoJoin = not settings.autoJoin
            settings.enabled = settings.autoJoin
            saveSettings(settings)
            updateToggleBar()
            if _G.AutoJoinerUI and _G.AutoJoinerUI.updateAutoJoinToggle then
                _G.AutoJoinerUI.updateAutoJoinToggle(settings.autoJoin)
            end
        end
    end)

    -- Hover effect
    toggleButton.MouseEnter:Connect(function()
        TweenService:Create(toggleBarContainer, TweenInfo.new(0.15), {
            Size = UDim2.new(0, 195, 0, 37)
        }):Play()
        TweenService:Create(toggleStroke, TweenInfo.new(0.15), {
            Thickness = 2,
            Transparency = 0
        }):Play()
    end)

    toggleButton.MouseLeave:Connect(function()
        TweenService:Create(toggleBarContainer, TweenInfo.new(0.15), {
            Size = UDim2.new(0, 190, 0, 35)
        }):Play()
        TweenService:Create(toggleStroke, TweenInfo.new(0.15), {
            Thickness = 1,
            Transparency = 0.25
        }):Play()
    end)

    -- ===== SNIPER UI TOGGLE BAR (Top Middle, looks identical) =====
    local sniperToggleContainer = Instance.new("Frame")
    sniperToggleContainer.Name = "SniperToggleContainer"
    sniperToggleContainer.AnchorPoint = Vector2.new(0.5, 0)
    -- Place to the right of the Auto Joiner toggle bar
    sniperToggleContainer.Position = UDim2.new(0.5, 120, 0, 15)
    sniperToggleContainer.Size = UDim2.new(0,190, 0, 35)
    sniperToggleContainer.BackgroundColor3 = Color3.fromRGB(22, 14, 18)
    sniperToggleContainer.BorderSizePixel = 0
    sniperToggleContainer.BackgroundTransparency = 0.15
    sniperToggleContainer.Parent = screenGui

    local sniperCorner = Instance.new("UICorner", sniperToggleContainer)
    sniperCorner.CornerRadius = UDim.new(0, 10)

    local sniperStroke = Instance.new("UIStroke", sniperToggleContainer)
    sniperStroke.Thickness = 1
    sniperStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    sniperStroke.Color = Color3.fromRGB(90, 40, 50)
    sniperStroke.Transparency = 0.25

    local sniperPadding = Instance.new("UIPadding", sniperToggleContainer)
    sniperPadding.PaddingTop = UDim.new(0, 8)
    sniperPadding.PaddingBottom = UDim.new(0, 8)
    sniperPadding.PaddingLeft = UDim.new(0, 12)
    sniperPadding.PaddingRight = UDim.new(0, 12)

    local sniperTitle = Instance.new("TextLabel")
    sniperTitle.Name = "Title"
    sniperTitle.Parent = sniperToggleContainer
    sniperTitle.BackgroundTransparency = 1
    sniperTitle.Position = UDim2.new(0, 0, 0, 0)
    sniperTitle.Size = UDim2.new(1, 0, 1, 0)
    sniperTitle.Font = Enum.Font.GothamMedium
    sniperTitle.Text = "Open Sniper (T)"
    sniperTitle.TextSize = 13
    sniperTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
    sniperTitle.TextXAlignment = Enum.TextXAlignment.Center
    sniperTitle.TextYAlignment = Enum.TextYAlignment.Center
    sniperTitle.ZIndex = 2

    local sniperButton = Instance.new("TextButton")
    sniperButton.Name = "ToggleButton"
    sniperButton.Size = UDim2.new(1, 0, 1, 0)
    sniperButton.Position = UDim2.new(0, 0, 0, 0)
    sniperButton.BackgroundTransparency = 1
    sniperButton.Text = ""
    sniperButton.AutoButtonColor = false
    sniperButton.Parent = sniperToggleContainer

    local function updateSniperToggleBar()
        if mainFrame.Visible then
            sniperTitle.Text = "Close Sniper (T)"
            sniperTitle.TextColor3 = Color3.fromRGB(255, 180, 180)
        else
            sniperTitle.Text = "Open Sniper (T)"
            sniperTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
        end
    end

    local function toggleMainUI()
        mainFrame.Visible = not mainFrame.Visible
        updateSniperToggleBar()
    end

    updateSniperToggleBar()

    sniperButton.MouseButton1Click:Connect(toggleMainUI)
    
    -- Connect minimize button to the same toggle function
    minimizeButton.MouseButton1Click:Connect(toggleMainUI)

    sniperButton.MouseEnter:Connect(function()
        TweenService:Create(sniperToggleContainer, TweenInfo.new(0.15), {
            Size = UDim2.new(0, 195, 0, 37)
        }):Play()
        TweenService:Create(sniperStroke, TweenInfo.new(0.15), {
            Thickness = 2,
            Transparency = 0
        }):Play()
    end)

    sniperButton.MouseLeave:Connect(function()
        TweenService:Create(sniperToggleContainer, TweenInfo.new(0.15), {
            Size = UDim2.new(0, 190, 0, 35)
        }):Play()
        TweenService:Create(sniperStroke, TweenInfo.new(0.15), {
            Thickness = 1,
            Transparency = 0.25
        }):Play()
    end)

    -- Bind T key to toggle the main UI (ignore when typing)
    local UserInputService = game:GetService("UserInputService")
    local tBindConn = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.T then
            if UserInputService:GetFocusedTextBox() then return end
            toggleMainUI()
        end
    end)
    table.insert(_activeConnections, tBindConn)

    -- Tab system
    local tabs = {}
    local activeTab = nil
    local tabIndicator = nil

    local function createTabButton(name, text, order)
        local tabButton = Instance.new("TextButton")
        tabButton.Name = name .. "Tab"
        tabButton.Size = UDim2.new(0.23, 0, 1, 0)
        tabButton.Position = UDim2.new((order - 1) * 0.25, 0, 0, 0)
        tabButton.BackgroundTransparency = 1
        tabButton.Text = text
        tabButton.TextColor3 = Color3.fromRGB(120, 120, 120)
        tabButton.TextSize = 14
        tabButton.Font = Enum.Font.GothamSemibold
        tabButton.Parent = tabContainer
        
        tabButton.MouseButton1Click:Connect(function()
            for _, tab in pairs(tabs) do
                -- Reset all tabs to default size
                TweenService:Create(tab.button, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    TextColor3 = Color3.fromRGB(120, 120, 120),
                    TextSize = 14
                }):Play()
                tab.content.Visible = false
            end
            
            -- Pop up the active tab
            TweenService:Create(tabButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                TextColor3 = Color3.fromRGB(255, 255, 255),
                TextSize = 15
            }):Play()
            tabs[name].content.Visible = true
            activeTab = name
            
            -- If switching into the Radar tab, ensure the list renders immediately
            if name == "radar" and updateRadarDisplay then
                updateRadarDisplay()
            end
            
            -- Animate tab indicator
            if not tabIndicator then
                tabIndicator = Instance.new("Frame")
                tabIndicator.Size = UDim2.new(0.18, 0, 0, 1.5) -- Thinner line
                tabIndicator.Position = UDim2.new(tabButton.Position.X.Scale + 0.025, 0, 1, -1)
                tabIndicator.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
                tabIndicator.BackgroundTransparency = 0.2
                tabIndicator.BorderSizePixel = 0
                tabIndicator.Parent = tabContainer
                
                -- Add subtle glow to tab indicator
                local indicatorGlow = Instance.new("UIStroke")
                indicatorGlow.Color = Color3.fromRGB(255, 100, 100)
                indicatorGlow.Thickness = 1.5
                indicatorGlow.Transparency = 0.4
                indicatorGlow.Parent = tabIndicator
            else
                local tween = TweenService:Create(
                    tabIndicator,
                    TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                    {Position = UDim2.new(tabButton.Position.X.Scale + 0.025, 0, 1, -1)}
                )
                tween:Play()
            end
        end)
        
        return tabButton
    end

    local function createContentFrame(name)
        local contentFrame = Instance.new("ScrollingFrame")
        contentFrame.Name = name .. "Content"
        contentFrame.Size = UDim2.new(1, 0, 1, 0)
        contentFrame.Position = UDim2.new(0, 0, 0, 0)
        contentFrame.BackgroundTransparency = 1
        contentFrame.BorderSizePixel = 0
        contentFrame.ScrollBarThickness = 4
        contentFrame.ScrollBarImageColor3 = Color3.fromRGB(60, 60, 60)
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        contentFrame.Visible = false
        contentFrame.Parent = contentContainer
        
        -- Add padding to content frame
        local paddingFrame = Instance.new("UIPadding")
        paddingFrame.PaddingLeft = UDim.new(0, 20)
        paddingFrame.PaddingRight = UDim.new(0, 20)
        paddingFrame.PaddingTop = UDim.new(0, 10)
        paddingFrame.PaddingBottom = UDim.new(0, 10)
        paddingFrame.Parent = contentFrame
        
        local listLayout = Instance.new("UIListLayout")
        listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        listLayout.Padding = UDim.new(0, 8)
        listLayout.Parent = contentFrame
        
        listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            contentFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 40)
        end)
        
        return contentFrame
    end

    -- Create tabs
    local mainTab = createTabButton("main", "MAIN", 1)
    local settingsTab = createTabButton("settings", "SETTINGS", 2)
    local modulesTab = createTabButton("modules", "MODULES", 3)
    local radarTab = createTabButton("radar", "RADAR", 4)

    local mainContent = createContentFrame("main")
    local settingsContent = createContentFrame("settings")
    local modulesContent = createContentFrame("modules")
    local radarContent = createContentFrame("radar")

    tabs = {
        main = {button = mainTab, content = mainContent},
        settings = {button = settingsTab, content = settingsContent},
        modules = {button = modulesTab, content = modulesContent},
        radar = {button = radarTab, content = radarContent}
    }

    -- Small black box with Radar Settings inside the EDIT tab
    -- Single-instance Radar Settings modal
    local radarSettingsModal

    -- Show MAIN by default so UI isn't blank on first open
    for _, t in pairs(tabs) do
        t.content.Visible = false
        t.button.TextColor3 = Color3.fromRGB(120, 120, 120)
        t.button.TextSize = 14
    end
    tabs.main.content.Visible = true
    tabs.main.button.TextColor3 = Color3.fromRGB(255, 255, 255)
    tabs.main.button.TextSize = 15 -- Pop up the active tab
    activeTab = "main"
    -- Create the indicator in the right spot initially
    tabIndicator = Instance.new("Frame")
    tabIndicator.Size = UDim2.new(0.18, 0, 0, 1.5) -- Thinner line
    tabIndicator.Position = UDim2.new(tabs.main.button.Position.X.Scale + 0.025, 0, 1, -1)
    tabIndicator.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
    tabIndicator.BackgroundTransparency = 0.2
    tabIndicator.BorderSizePixel = 0
    tabIndicator.Parent = tabContainer
    
    -- Add stronger glow to initial tab indicator
    local indicatorGlow = Instance.new("UIStroke")
    indicatorGlow.Color = Color3.fromRGB(255, 100, 100)
    indicatorGlow.Thickness = 1.5
    indicatorGlow.Transparency = 0.4
    indicatorGlow.Parent = tabIndicator

    -- Helper functions for modern UI elements
    local function createModernToggle(parent, text, defaultState, callback)
        local toggleContainer = Instance.new("Frame")
        toggleContainer.Name = text .. "Toggle"
        toggleContainer.Size = UDim2.new(1, 0, 0, 35)
        toggleContainer.BackgroundTransparency = 1
        toggleContainer.LayoutOrder = #parent:GetChildren()
        toggleContainer.Parent = parent
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -70, 1, 0)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = text
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.TextSize = 14
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Font = Enum.Font.Gotham
        label.Parent = toggleContainer
        
        -- Subtle text stroke for module labels
        local labelStroke = Instance.new("UIStroke")
        labelStroke.Color = Color3.fromRGB(180, 180, 180)
        labelStroke.Thickness = 0.6
        labelStroke.Transparency = 1
        labelStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        labelStroke.Parent = label
        
        local switch = Instance.new("Frame")
        switch.Size = UDim2.new(0, 50, 0, 26)
        switch.Position = UDim2.new(1, -50, 0.5, -13)
        switch.BackgroundColor3 = defaultState and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(40, 40, 40)
        switch.BorderSizePixel = 0
        switch.Parent = toggleContainer
        
        local switchCorner = Instance.new("UICorner")
        switchCorner.CornerRadius = UDim.new(0, 13)
        switchCorner.Parent = switch
        
        local knob = Instance.new("Frame")
        knob.Size = UDim2.new(0, 22, 0, 22)
        knob.Position = defaultState and UDim2.new(1, -24, 0, 2) or UDim2.new(0, 2, 0, 2)
        knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        knob.BorderSizePixel = 0
        knob.Parent = switch
        
        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(0, 11)
        knobCorner.Parent = knob
        
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(1, 0, 1, 0)
        button.BackgroundTransparency = 1
        button.Text = ""
        button.Parent = toggleContainer
        
        local isOn = defaultState
        
        local function updateVisuals()
            local tween1 = TweenService:Create(
                switch,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                {BackgroundColor3 = isOn and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(40, 40, 40)}
            )
            
            local tween2 = TweenService:Create(
                knob,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                {Position = isOn and UDim2.new(1, -24, 0, 2) or UDim2.new(0, 2, 0, 2)}
            )
            
            tween1:Play()
            tween2:Play()
        end
        
        button.MouseButton1Click:Connect(function()
            isOn = not isOn
            updateVisuals()
            if callback then callback(isOn) end
        end)
        
        -- Hover animations for label
        button.MouseEnter:Connect(function()
            TweenService:Create(label, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                TextColor3 = Color3.fromRGB(255, 255, 255)
            }):Play()
            TweenService:Create(labelStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                Transparency = 0.75
            }):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(label, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                TextColor3 = Color3.fromRGB(200, 200, 200)
            }):Play()
            TweenService:Create(labelStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                Transparency = 1
            }):Play()
        end)
        
        -- Return button, state, and update function
        local updateFunc = function(newState)
            isOn = newState
            updateVisuals()
        end
        
        return button, isOn, updateFunc
    end

    local function createModernSlider(parent, text, min, max, default, suffix, callback)
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Name = text .. "Slider"
        sliderContainer.Size = UDim2.new(1, 0, 0, 65)
        sliderContainer.BackgroundTransparency = 1
        sliderContainer.LayoutOrder = #parent:GetChildren()
        sliderContainer.Parent = parent
        
        -- Pre-calc right-side reserved width (value box + optional suffix)
        local valueBoxWidth = 80
        local hasSuffix = (suffix ~= nil and suffix ~= "")
        local suffixWidthPre = hasSuffix and 36 or 0
        local gapPre = hasSuffix and 6 or 0
        local reservedRight = valueBoxWidth + suffixWidthPre + gapPre

        local label = Instance.new("TextLabel")
        -- Ensure label leaves room for right-side controls no matter the container width
        label.Size = UDim2.new(1, -(reservedRight + 10), 0, 20)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = text
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.TextSize = 14
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Font = Enum.Font.Gotham
        label.Parent = sliderContainer
        
        -- Subtle text stroke for label
        local labelStroke = Instance.new("UIStroke")
        labelStroke.Color = Color3.fromRGB(180, 180, 180)
        labelStroke.Thickness = 0.6
        labelStroke.Transparency = 1
        labelStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        labelStroke.Parent = label
        
        -- Editable TextBox for value
        local valueBox = Instance.new("TextBox")
        valueBox.Size = UDim2.new(0, 80, 0, 25)
        valueBox.Position = UDim2.new(1, -valueBoxWidth, 0, -2)
        valueBox.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        valueBox.BorderSizePixel = 0
        -- Format initial display based on whether it's a whole number (like max players)
        if default == math.floor(default) and max <= 50 then
            valueBox.Text = tostring(math.floor(default))
        else
            valueBox.Text = string.format("%.1f", default)
        end
        valueBox.TextColor3 = Color3.fromRGB(255, 255, 255)
        valueBox.TextSize = 12
        valueBox.TextXAlignment = Enum.TextXAlignment.Center
        valueBox.Font = Enum.Font.GothamSemibold
        valueBox.ClearTextOnFocus = false
        valueBox.Parent = sliderContainer
        
        local valueBoxCorner = Instance.new("UICorner")
        valueBoxCorner.CornerRadius = UDim.new(0, 4)
        valueBoxCorner.Parent = valueBox

        -- Optional unit label (e.g., M/s) placed to the RIGHT of the value box
        if hasSuffix then
            local suffixWidth = suffixWidthPre
            local gap = gapPre
            -- Shift the value box left to make room for the suffix
            valueBox.Position = UDim2.new(1, -(valueBoxWidth + suffixWidth + gap), 0, -2)

            local unitLabel = Instance.new("TextLabel")
            unitLabel.Name = "UnitLabel"
        unitLabel.Size = UDim2.new(0, suffixWidth, 0, 25)
            unitLabel.Position = UDim2.new(1, -suffixWidth, 0, -2)
            unitLabel.BackgroundTransparency = 1
            unitLabel.Text = suffix
            unitLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
            unitLabel.TextSize = 12
            unitLabel.TextXAlignment = Enum.TextXAlignment.Center
            unitLabel.Font = Enum.Font.Gotham
            unitLabel.Parent = sliderContainer
        end
        
        local sliderBg = Instance.new("Frame")
        sliderBg.Size = UDim2.new(1, 0, 0, 6)
        sliderBg.Position = UDim2.new(0, 0, 0, 35)
        sliderBg.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        sliderBg.BorderSizePixel = 0
        sliderBg.Parent = sliderContainer
        
        local sliderBgCorner = Instance.new("UICorner")
        sliderBgCorner.CornerRadius = UDim.new(0, 3)
        sliderBgCorner.Parent = sliderBg
        
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
        sliderFill.Position = UDim2.new(0, 0, 0, 0)
        sliderFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        sliderFill.BorderSizePixel = 0
        sliderFill.Parent = sliderBg
        
        local sliderFillCorner = Instance.new("UICorner")
        sliderFillCorner.CornerRadius = UDim.new(0, 3)
        sliderFillCorner.Parent = sliderFill
        
        local sliderKnob = Instance.new("Frame")
        sliderKnob.Size = UDim2.new(0, 16, 0, 16)
        sliderKnob.Position = UDim2.new((default - min) / (max - min), -8, 0.5, -8)
        sliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        sliderKnob.BorderSizePixel = 0
        sliderKnob.Parent = sliderBg
        
        local sliderKnobCorner = Instance.new("UICorner")
        sliderKnobCorner.CornerRadius = UDim.new(0, 8)
        sliderKnobCorner.Parent = sliderKnob
        
        local value = default
        
        local function updateSliderFromValue(newValue)
            value = math.clamp(tonumber(newValue) or default, min, max)
            local relativeX = (value - min) / (max - min)
            
            sliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
            sliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
            -- Format differently based on whether it's a whole number (like max players)
            if value == math.floor(value) and max <= 50 then
                valueBox.Text = tostring(math.floor(value))
            else
                valueBox.Text = string.format("%.1f", value)
            end
            
            if callback then callback(value) end
        end
        
        -- TextBox input handling
        valueBox.FocusLost:Connect(function()
            updateSliderFromValue(valueBox.Text)
        end)
        
        -- Slider dragging - fixed to not interfere with UI movement
        local dragging = false
        local dragConnection = nil
        local dragEndConnection = nil
        
        local function startDrag()
            if dragging then return end -- Prevent multiple drag sessions
            dragging = true
            -- Disable main frame dragging while slider is being used
            mainFrame.Draggable = false
            
            dragConnection = game:GetService("UserInputService").InputChanged:Connect(function(input)
                if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                    local relativeX = math.clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
                    local newValue = math.floor(min + (max - min) * relativeX)
                    updateSliderFromValue(newValue)
                end
            end)
            
            dragEndConnection = game:GetService("UserInputService").InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 and dragging then
                    dragging = false
                    mainFrame.Draggable = true
                    if dragConnection then 
                        dragConnection:Disconnect()
                        dragConnection = nil
                    end
                    if dragEndConnection then 
                        dragEndConnection:Disconnect()
                        dragEndConnection = nil
                    end
                end
            end)
        end
        
        sliderKnob.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                startDrag()
            end
        end)
        
        sliderBg.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local relativeX = math.clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
                local newValue = math.floor(min + (max - min) * relativeX)
                updateSliderFromValue(newValue)
                startDrag()
            end
        end)
        
        -- Hover effect for label stroke
        sliderContainer.MouseEnter:Connect(function()
            TweenService:Create(labelStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                Transparency = 0.75
            }):Play()
        end)
        
        sliderContainer.MouseLeave:Connect(function()
            TweenService:Create(labelStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                Transparency = 1
            }):Play()
        end)
        
        return sliderContainer, function() return value end
    end

    -- Simple titled section container for grouping settings
    local function createSection(parent, title)
        local section = Instance.new("Frame")
        section.Name = title .. "Section"
        section.Size = UDim2.new(1, 0, 0, 0)
        section.AutomaticSize = Enum.AutomaticSize.Y
        section.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        section.BorderSizePixel = 0
        section.LayoutOrder = #parent:GetChildren()
        section.Parent = parent

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = section

        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(1, -30, 0, 24)
        titleLabel.Position = UDim2.new(0, 15, 0, 8)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = string.upper(title)
        titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        titleLabel.TextSize = 14
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.Font = Enum.Font.GothamBold
        titleLabel.Parent = section

        local inner = Instance.new("Frame")
        inner.Name = "Content"
        inner.Size = UDim2.new(1, -30, 0, 0)
        inner.Position = UDim2.new(0, 15, 0, 40)
        inner.BackgroundTransparency = 1
        inner.AutomaticSize = Enum.AutomaticSize.Y
        inner.Parent = section

        local list = Instance.new("UIListLayout")
        list.SortOrder = Enum.SortOrder.LayoutOrder
        list.Padding = UDim.new(0, 8)
        list.Parent = inner

        -- Add a bit of bottom padding so last controls don't clip the rounded corners
        local innerPad = Instance.new("UIPadding")
        innerPad.PaddingBottom = UDim.new(0, 10)
        innerPad.Parent = inner

        return inner
    end

    local function createModernInput(parent, text, placeholder, default, callback)
        local inputContainer = Instance.new("Frame")
        inputContainer.Name = text .. "Input"
        inputContainer.Size = UDim2.new(1, 0, 0, 60)
        inputContainer.BackgroundTransparency = 1
        inputContainer.LayoutOrder = #parent:GetChildren()
        inputContainer.Parent = parent
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = text
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.TextSize = 14
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Font = Enum.Font.Gotham
        label.Parent = inputContainer
        
        local inputBg = Instance.new("Frame")
        inputBg.Size = UDim2.new(1, 0, 0, 35)
        inputBg.Position = UDim2.new(0, 0, 0, 25)
        inputBg.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        inputBg.BorderSizePixel = 0
        inputBg.Parent = inputContainer
        
        local inputBgCorner = Instance.new("UICorner")
        inputBgCorner.CornerRadius = UDim.new(0, 6)
        inputBgCorner.Parent = inputBg
        
        local inputBox = Instance.new("TextBox")
        inputBox.Size = UDim2.new(1, -10, 1, 0)
        inputBox.Position = UDim2.new(0, 5, 0, 0)
        inputBox.BackgroundTransparency = 1
        inputBox.Text = default or ""
        inputBox.PlaceholderText = placeholder
        inputBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
        inputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
        inputBox.TextSize = 13
        inputBox.TextXAlignment = Enum.TextXAlignment.Left
        inputBox.Font = Enum.Font.Gotham
        inputBox.ClearTextOnFocus = false
        inputBox.Parent = inputBg
        
        inputBox.FocusLost:Connect(function()
            if callback then callback(inputBox.Text) end
        end)
        
        return inputBox
    end

    local function createDropdown(parent, text, options, default, callback)
        local dropdownContainer = Instance.new("Frame")
        dropdownContainer.Name = text .. "Dropdown"
        dropdownContainer.Size = UDim2.new(1, 0, 0, 55)
        dropdownContainer.BackgroundTransparency = 1
        dropdownContainer.LayoutOrder = #parent:GetChildren()
        dropdownContainer.Parent = parent
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = text
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.TextSize = 14
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Font = Enum.Font.Gotham
        label.Parent = dropdownContainer
        
        local dropdownBg = Instance.new("Frame")
        dropdownBg.Size = UDim2.new(1, 0, 0, 35)
        dropdownBg.Position = UDim2.new(0, 0, 0, 25)
        dropdownBg.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        dropdownBg.BorderSizePixel = 0
        dropdownBg.Parent = dropdownContainer
        
        local dropdownBgCorner = Instance.new("UICorner")
        dropdownBgCorner.CornerRadius = UDim.new(0, 6)
        dropdownBgCorner.Parent = dropdownBg
        
        local selectedLabel = Instance.new("TextLabel")
        selectedLabel.Size = UDim2.new(1, -35, 1, 0)
        selectedLabel.Position = UDim2.new(0, 10, 0, 0)
        selectedLabel.BackgroundTransparency = 1
        selectedLabel.Text = default
        selectedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        selectedLabel.TextSize = 13
        selectedLabel.TextXAlignment = Enum.TextXAlignment.Left
        selectedLabel.Font = Enum.Font.Gotham
        selectedLabel.Parent = dropdownBg
        
        local arrow = Instance.new("TextLabel")
        arrow.Size = UDim2.new(0, 20, 1, 0)
        arrow.Position = UDim2.new(1, -25, 0, 0)
        arrow.BackgroundTransparency = 1
        arrow.Text = "▼"
        arrow.TextColor3 = Color3.fromRGB(150, 150, 150)
        arrow.TextSize = 12
        arrow.Font = Enum.Font.Gotham
        arrow.Parent = dropdownBg
        
        local dropdownButton = Instance.new("TextButton")
        dropdownButton.Size = UDim2.new(1, 0, 1, 0)
        dropdownButton.BackgroundTransparency = 1
        dropdownButton.Text = ""
        dropdownButton.Parent = dropdownBg
        
        -- Dropdown menu (simplified for now)
        dropdownButton.MouseButton1Click:Connect(function()
            -- Cycle through options
            local currentIndex = 1
            for i, option in ipairs(options) do
                if option == selectedLabel.Text then
                    currentIndex = i
                    break
                end
            end
            currentIndex = currentIndex % #options + 1
            selectedLabel.Text = options[currentIndex]
            if callback then callback(options[currentIndex]) end
        end)
        
        return dropdownContainer
    end

    -- MAIN TAB CONTENT
    local statusFrame = Instance.new("Frame")
    statusFrame.Name = "StatusFrame"
    statusFrame.Size = UDim2.new(1, 0, 0, 120)
    statusFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    statusFrame.BorderSizePixel = 0
    statusFrame.LayoutOrder = 1
    statusFrame.Parent = mainContent

    local statusFrameCorner = Instance.new("UICorner")
    statusFrameCorner.CornerRadius = UDim.new(0, 8)
    statusFrameCorner.Parent = statusFrame

    local statusTitle = Instance.new("TextLabel")
    statusTitle.Size = UDim2.new(1, -30, 0, 30)
    statusTitle.Position = UDim2.new(0, 15, 0, 10)
    statusTitle.BackgroundTransparency = 1
    statusTitle.Text = "JOINER | STATUS"
    statusTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusTitle.TextSize = 16
    statusTitle.TextXAlignment = Enum.TextXAlignment.Left
    statusTitle.Font = Enum.Font.GothamBold
    statusTitle.Parent = statusFrame

    local statusText = Instance.new("TextLabel")
    statusText.Size = UDim2.new(1, -30, 0, 20)
    statusText.Position = UDim2.new(0, 15, 0, 45)
    statusText.BackgroundTransparency = 1
    statusText.Text = "Ready"
    statusText.TextColor3 = Color3.fromRGB(100, 255, 100)
    statusText.TextSize = 14
    statusText.TextXAlignment = Enum.TextXAlignment.Left
    statusText.Font = Enum.Font.Gotham
    statusText.Parent = statusFrame

    local foundText = Instance.new("TextLabel")
    foundText.Size = UDim2.new(1, -30, 0, 20)
    foundText.Position = UDim2.new(0, 15, 0, 70)
    foundText.BackgroundTransparency = 1
    foundText.Text = "Found: 0"
    foundText.TextColor3 = Color3.fromRGB(200, 200, 200)
    foundText.TextSize = 14
    foundText.TextXAlignment = Enum.TextXAlignment.Left
    foundText.Font = Enum.Font.Gotham
    foundText.Parent = statusFrame

    -- Shared setter to keep all UI/components in sync
    setAutoJoinEnabled = function(state)
        settings.autoJoin = state and true or false
        settings.enabled = settings.autoJoin -- legacy sync
        
        -- Track when autojoiner is enabled to ignore old brainrots
        if settings.autoJoin then
            settings.autoJoinEnabledAt = os.time()
            -- Immediately poll the relay so we don't wait for the next interval
            pcall(function()
                pollJSONBinRelay()
            end)
        else
            settings.autoJoinEnabledAt = nil
        end
        
        saveSettings(settings)

        -- Update top bar visuals
        if updateToggleBar then updateToggleBar() end

        -- Update main tab status text
        statusText.Text = settings.autoJoin and "Active" or "Ready"
        statusText.TextColor3 = settings.autoJoin and Color3.fromRGB(255, 200, 100) or Color3.fromRGB(100, 255, 100)

        -- Update the main-tab toggle visual if created
        if _G.AutoJoinerUI and _G.AutoJoinerUI.updateAutoJoinToggle then
            _G.AutoJoinerUI.updateAutoJoinToggle(settings.autoJoin)
        end

        -- Notify user about AutoJoin state change
        pcall(function()
            showModuleNotification("AutoJoin", settings.autoJoin)
        end)
    end

    -- Enable toggle in main tab (synced with top bar auto-join)
    local enableToggleButton, enableInitial, updateEnableToggle = createModernToggle(mainContent, "Enable AutoJoiner", settings.autoJoin, function(state)
        setAutoJoinEnabled(state)
    end)

    -- Allow top bar to update this toggle visually
    _G.AutoJoinerUI = _G.AutoJoinerUI or {}
    _G.AutoJoinerUI.updateAutoJoinToggle = updateEnableToggle

    -- STATS SECTION IN MAIN TAB
    local statsHeader = Instance.new("Frame")
    statsHeader.Name = "StatsHeader"
    statsHeader.Size = UDim2.new(1, 0, 0, 40)
    statsHeader.BackgroundTransparency = 1
    statsHeader.LayoutOrder = #mainContent:GetChildren()
    statsHeader.Parent = mainContent

    local statsTitle = Instance.new("TextLabel")
    statsTitle.Size = UDim2.new(1, 0, 0, 25)
    statsTitle.Position = UDim2.new(0, 0, 0, 0)
    statsTitle.BackgroundTransparency = 1
    statsTitle.Text = "SERVER STATS"
    statsTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    statsTitle.TextSize = 14
    statsTitle.TextXAlignment = Enum.TextXAlignment.Left
    statsTitle.Font = Enum.Font.GothamBold
    statsTitle.Parent = statsHeader

    local statsDivider = Instance.new("Frame")
    statsDivider.Size = UDim2.new(1, 0, 0, 1)
    statsDivider.Position = UDim2.new(0, 0, 0, 30)
    statsDivider.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    statsDivider.BorderSizePixel = 0
    statsDivider.Parent = statsHeader

    -- Stats Container
    local statsContainer = Instance.new("Frame")
    statsContainer.Name = "StatsContainer"
    statsContainer.Size = UDim2.new(1, 0, 0, 240)
    statsContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    statsContainer.BorderSizePixel = 0
    statsContainer.LayoutOrder = #mainContent:GetChildren()
    statsContainer.Parent = mainContent

    local statsContainerCorner = Instance.new("UICorner")
    statsContainerCorner.CornerRadius = UDim.new(0, 8)
    statsContainerCorner.Parent = statsContainer

    local statsContainerPadding = Instance.new("UIPadding")
    statsContainerPadding.PaddingLeft = UDim.new(0, 15)
    statsContainerPadding.PaddingRight = UDim.new(0, 15)
    statsContainerPadding.PaddingTop = UDim.new(0, 15)
    statsContainerPadding.PaddingBottom = UDim.new(0, 15)
    statsContainerPadding.Parent = statsContainer

    -- Highest Brainrot Name
    local highestNameLabel = Instance.new("TextLabel")
    highestNameLabel.Size = UDim2.new(1, 0, 0, 25)
    highestNameLabel.Position = UDim2.new(0, 0, 0, 0)
    highestNameLabel.BackgroundTransparency = 1
    highestNameLabel.Text = "Highest Brainrot: Searching..."
    highestNameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    highestNameLabel.TextSize = 14
    highestNameLabel.TextXAlignment = Enum.TextXAlignment.Left
    highestNameLabel.Font = Enum.Font.GothamSemibold
    highestNameLabel.Parent = statsContainer

    -- Mutations
    local mutationsLabel = Instance.new("TextLabel")
    mutationsLabel.Size = UDim2.new(1, 0, 0, 20)
    mutationsLabel.Position = UDim2.new(0, 0, 0, 30)
    mutationsLabel.BackgroundTransparency = 1
    mutationsLabel.Text = "Mutations: Unknown"
    mutationsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    mutationsLabel.TextSize = 12
    mutationsLabel.TextXAlignment = Enum.TextXAlignment.Left
    mutationsLabel.Font = Enum.Font.Gotham
    mutationsLabel.Parent = statsContainer

    -- Money Per Second
    local moneyLabel = Instance.new("TextLabel")
    moneyLabel.Size = UDim2.new(1, 0, 0, 20)
    moneyLabel.Position = UDim2.new(0, 0, 0, 55)
    moneyLabel.BackgroundTransparency = 1
    moneyLabel.Text = "Money/s: Unknown"
    moneyLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    moneyLabel.TextSize = 12
    moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
    moneyLabel.Font = Enum.Font.GothamBold
    moneyLabel.Parent = statsContainer

    -- Owner Name with Gradient
    local ownerLabel = Instance.new("TextLabel")
    ownerLabel.Size = UDim2.new(1, 0, 0, 25)
    ownerLabel.Position = UDim2.new(0, 0, 0, 85)
    ownerLabel.BackgroundTransparency = 1
    ownerLabel.Text = "Owner: Searching..."
    ownerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ownerLabel.TextSize = 16
    ownerLabel.TextXAlignment = Enum.TextXAlignment.Left
    ownerLabel.Font = Enum.Font.GothamBold
    ownerLabel.Parent = statsContainer

    -- Add gradient to owner name (optimized for short names)
    local ownerGradient = Instance.new("UIGradient")
    ownerGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 100, 100)), -- Red
        ColorSequenceKeypoint.new(0.3, Color3.fromRGB(255, 150, 100)), -- Orange  
        ColorSequenceKeypoint.new(0.6, Color3.fromRGB(255, 200, 100)), -- Yellow
        ColorSequenceKeypoint.new(1.0, Color3.fromRGB(100, 255, 100))  -- Green
    }
    ownerGradient.Rotation = 0  -- Horizontal gradient works better for names
    ownerGradient.Parent = ownerLabel

    -- Timer Display
    local timerLabel = Instance.new("TextLabel")
    timerLabel.Size = UDim2.new(1, 0, 0, 25)
    timerLabel.Position = UDim2.new(0, 0, 0, 120)
    timerLabel.BackgroundTransparency = 1
    timerLabel.Text = "Timer: Searching..."
    timerLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
    timerLabel.TextSize = 14
    timerLabel.TextXAlignment = Enum.TextXAlignment.Left
    timerLabel.Font = Enum.Font.GothamBold
    timerLabel.Parent = statsContainer

    -- Last Updated
    local lastUpdatedLabel = Instance.new("TextLabel")
    lastUpdatedLabel.Size = UDim2.new(1, 0, 0, 20)
    lastUpdatedLabel.Position = UDim2.new(0, 0, 0, 155)
    lastUpdatedLabel.BackgroundTransparency = 1
    lastUpdatedLabel.Text = "Last Updated: Never"
    lastUpdatedLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
    lastUpdatedLabel.TextSize = 10
    lastUpdatedLabel.TextXAlignment = Enum.TextXAlignment.Left
    lastUpdatedLabel.Font = Enum.Font.Gotham
    lastUpdatedLabel.Parent = statsContainer

    -- Global references for stats
    _G.StatsLabels = {
        highestName = highestNameLabel,
        mutations = mutationsLabel,
        money = moneyLabel,
        owner = ownerLabel,
        timer = timerLabel,
        lastUpdated = lastUpdatedLabel
    }

    -- SETTINGS TAB CONTENT
    -- Group settings into clear sections

    -- General section
    local generalSection = createSection(settingsContent, "General")
    local maxPlayersSlider = createModernSlider(generalSection, "Max Players", 1, 8, settings.maxPlayers, "", function(value)
        settings.maxPlayers = value
        saveSettings(settings)
    end)
    addTooltip(maxPlayersSlider, "Maximum number of players in a server to join (lower = faster joining)")

    -- Money/s Range section
    local rangeSection = createSection(settingsContent, "Money/s Range")
    -- Sliders accept values in millions per second; 10.0 means $10M/s
    local sliderNotifyDebounce
    local function notifySlider(label, value)
        -- debounce rapid drags
        if sliderNotifyDebounce then task.cancel(sliderNotifyDebounce) end
        sliderNotifyDebounce = task.delay(0.25, function()
            local display = string.format("%.1f M/s", value)
            pcall(function() showValueNotification(label, display) end)
        end)
    end

    local minMoneySlider = createModernSlider(rangeSection, "Minimum ($M per second)", 0, 9998.0, settings.minMoney, "M/s", function(value)
        settings.minMoney = value
        saveSettings(settings)
        notifySlider("Minimum Value", value)
    end)
    addTooltip(minMoneySlider, "Only auto join servers with brainrots above this value (1 = $1M/s)")

    local maxMoneySlider = createModernSlider(rangeSection, "Maximum ($M per second)", 0, 9999.0, settings.maxMoney, "M/s", function(value)
        settings.maxMoney = value
        saveSettings(settings)
        notifySlider("Maximum Value", value)
    end)
    addTooltip(maxMoneySlider, "Only auto join servers with brainrots below this value (10 = $10M/s)")
    do
        -- Helper hint for interpreting the sliders
        local hint = Instance.new("TextLabel")
        hint.Name = "RangeHint"
        -- Allow wrapping and auto-size vertically so it never clips when UI is small
        hint.Size = UDim2.new(1, 0, 0, 0)
        hint.AutomaticSize = Enum.AutomaticSize.Y
        hint.BackgroundTransparency = 1
        hint.Text = "Values are in millions per second. Example: 10.0 = $10M/s"
        hint.TextColor3 = Color3.fromRGB(150, 150, 150)
        hint.TextSize = 12
        hint.TextWrapped = true
        hint.TextTruncate = Enum.TextTruncate.None
        hint.TextXAlignment = Enum.TextXAlignment.Left
        hint.Font = Enum.Font.Gotham
        hint.LayoutOrder = 9999
        -- Add a little top padding so it breathes under the sliders
        local hintPad = Instance.new("UIPadding")
        hintPad.PaddingTop = UDim.new(0, 2)
        hintPad.Parent = hint
        hint.Parent = rangeSection
    end

    -- Brainrot Filters section
    local brainrotSection = createSection(settingsContent, "Brainrot Filters")
    createModernToggle(brainrotSection, "Ignore Unknown Pets", settings.ignoreUnknownPets, function(state)
        settings.ignoreUnknownPets = state
        saveSettings(settings)
        -- Notify when this setting is toggled
        pcall(function()
            showModuleNotification("Ignore Unknown Pets", state)
        end)
    end)
    createModernToggle(brainrotSection, "Join Before 30", settings.joinBefore30, function(state)
        settings.joinBefore30 = state
        saveSettings(settings)
        -- Notify when this setting is toggled
        pcall(function()
            showModuleNotification("Join Before 30", state)
        end)
    end)
    createModernToggle(brainrotSection, "Enable Only Join List", settings.enableOnlyJoinList, function(state)
        settings.enableOnlyJoinList = state
        saveSettings(settings)
        -- Notify when this setting is toggled
        pcall(function()
            -- Use a concise label in the banner
            showModuleNotification("Only Join List", state)
        end)
    end)
    createModernInput(brainrotSection, "Whitelist (Ignore $ Range)", "Enter brainrot names separated by commas", settings.whitelistList, function(text)
        settings.whitelistList = text
        saveSettings(settings)
    end)
    createModernInput(brainrotSection, "Only Join List", "Enter brainrot names separated by commas", settings.onlyJoinList, function(text)
        settings.onlyJoinList = text
        saveSettings(settings)
    end)
    createModernInput(brainrotSection, "Ignore List", "Enter brainrot names separated by commas", settings.ignoreList, function(text)
        settings.ignoreList = text
        saveSettings(settings)
    end)

    -- MODULES TAB CONTENT
    -- Base Toggles Section
    local baseTogglesHeader = Instance.new("Frame")
    baseTogglesHeader.Name = "BaseTogglesHeader"
    baseTogglesHeader.Size = UDim2.new(1, 0, 0, 40)
    baseTogglesHeader.BackgroundTransparency = 1
    baseTogglesHeader.LayoutOrder = 1
    baseTogglesHeader.Parent = modulesContent

    local baseTogglesTitle = Instance.new("TextLabel")
    baseTogglesTitle.Size = UDim2.new(1, 0, 0, 25)
    baseTogglesTitle.Position = UDim2.new(0, 0, 0, 0)
    baseTogglesTitle.BackgroundTransparency = 1
    baseTogglesTitle.Text = "BASE TOGGLES"
    baseTogglesTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    baseTogglesTitle.TextSize = 14
    baseTogglesTitle.TextXAlignment = Enum.TextXAlignment.Left
    baseTogglesTitle.Font = Enum.Font.GothamBold
    baseTogglesTitle.Parent = baseTogglesHeader

    -- Divider line like the one under tabs
    local baseTogglesDivider = Instance.new("Frame")
    baseTogglesDivider.Size = UDim2.new(1, 0, 0, 1)
    baseTogglesDivider.Position = UDim2.new(0, 0, 0, 30)
    baseTogglesDivider.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    baseTogglesDivider.BorderSizePixel = 0
    baseTogglesDivider.Parent = baseTogglesHeader

    local blackBaseToggle = createModernToggle(modulesContent, "Black Base", settings.blackBase, function(state)
        settings.blackBase = state
        
        -- Show notification
        showModuleNotification("Black Base", state)
        
        -- Function to make base black or restore original color
        local function toggleBlackBase(enable)
            local plots = workspace:FindFirstChild("Plots")
            if not plots then 
                -- Plots folder not found in workspace (silenced)
                return 
            end
            
            -- Use DisplayName if available, otherwise fall back to Name
            local playerDisplayName = Players.LocalPlayer.DisplayName
            local playerName = Players.LocalPlayer.Name
            
            -- Loop through all plots to find the player's plot
            for _, plot in pairs(plots:GetChildren()) do
                if plot:IsA("Model") then
                    local plotSign = plot:FindFirstChild("PlotSign")
                    if plotSign then
                        local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                        if surfaceGui then
                            local frame = surfaceGui:FindFirstChild("Frame")
                            if frame then
                                local textLabel = frame:FindFirstChild("TextLabel")
                                if textLabel then
                                    local fullText = textLabel.Text
                                    -- Extract name from "playername's Base" format and clean it
                                    local ownerName = fullText:match("(.+)'s [Bb]ase")
                                    
                                    -- Check if this is the local player's base (check both display name and username)
                                    if ownerName == playerDisplayName or ownerName == playerName then
                                        local decorations = plot:FindFirstChild("Decorations")
                                        if decorations then
                                            -- Function to change part color
                                            local function changePart(part)
                                                if part:IsA("BasePart") then
                                                    -- Check if part has a PointLight, if so, skip coloring it
                                                    if part:FindFirstChildOfClass("PointLight") then
                                                        return -- Skip this part to preserve lighting
                                                    end
                                                    
                                                    -- Check if the part's parent model contains any PointLight
                                                    local parentModel = part.Parent
                                                    if parentModel and parentModel:IsA("Model") then
                                                        for _, child in pairs(parentModel:GetDescendants()) do
                                                            if child:IsA("PointLight") then
                                                                return -- Skip all parts in models that contain PointLights
                                                            end
                                                        end
                                                    end
                                                    
                                                    if enable then
                                                        -- Store original color if not already stored
                                                        if not part:GetAttribute("OriginalColor") then
                                                            part:SetAttribute("OriginalColor", part.Color.R .. "," .. part.Color.G .. "," .. part.Color.B)
                                                        end
                                                        -- Make it black
                                                        part.Color = Color3.fromRGB(0, 0, 0)
                                                    else
                                                        -- Restore original color
                                                        local originalColor = part:GetAttribute("OriginalColor")
                                                        if originalColor then
                                                            local r, g, b = originalColor:match("([^,]+),([^,]+),([^,]+)")
                                                            part.Color = Color3.fromRGB(tonumber(r) * 255, tonumber(g) * 255, tonumber(b) * 255)
                                                        end
                                                    end
                                                end
                                            end
                                            
                            -- Process Side 1, Side 2, and Side 3
                            for i = 1, 3 do
                                local side = decorations:FindFirstChild("Side " .. i)
                                if side then
                                    for _, child in pairs(side:GetChildren()) do
                                        -- Case 1: Parts named "structure base home" directly in the side
                                        if child.Name == "structure base home" then
                                            changePart(child)
                                        -- Case 2: Any parts directly in the side (outside of models)
                                        elseif child:IsA("BasePart") then
                                            changePart(child)
                                        -- Case 3: Models named "Model" containing parts
                                        elseif child.Name == "Model" and child:IsA("Model") then
                                            for _, modelChild in pairs(child:GetChildren()) do
                                                changePart(modelChild)
                                            end
                                        -- Case 4: Folder named "Folder" in Side 2 containing parts
                                        elseif child.Name == "Folder" and child:IsA("Folder") and i == 2 then
                                            for _, folderChild in pairs(child:GetChildren()) do
                                                -- Check if it's a direct part
                                                if folderChild:IsA("BasePart") then
                                                    changePart(folderChild)
                                                -- Check if it's a model named "Side 2" containing parts
                                                elseif folderChild.Name == "Side 2" and folderChild:IsA("Model") then
                                                    for _, modelChild in pairs(folderChild:GetChildren()) do
                                                        changePart(modelChild)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end                                        -- Process parts directly in Decorations (outside of Side models)
                                            for _, child in pairs(decorations:GetChildren()) do
                                                -- Case 1: Parts named "structure base home" directly in decorations
                                                if child.Name == "structure base home" then
                                                    changePart(child)
                                                -- Case 2: Any parts directly in decorations (outside of Side models)
                                                elseif child:IsA("BasePart") then
                                                    changePart(child)
                                                -- Case 3: Models named "Model" containing parts (outside of Side models)
                                                elseif child.Name == "Model" and child:IsA("Model") then
                                                    for _, modelChild in pairs(child:GetChildren()) do
                                                        changePart(modelChild)
                                                    end
                                                end
                                            end
                                        end
                                        break -- Found the player's plot, no need to continue
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        
        toggleBlackBase(state)
        saveSettings(settings)
    end)
    addTooltip(blackBaseToggle, "Makes your plot base completely black")

    local transparentBasesToggle = createModernToggle(modulesContent, "Transparent Bases", settings.transparentBases, function(state)
        settings.transparentBases = state
        
        -- Show notification
        showModuleNotification("Transparent Bases", state)
        
        -- Function to make other players' bases transparent or restore original transparency
        local function toggleTransparentBases(enable)
            local plots = workspace:FindFirstChild("Plots")
            if not plots then 
                -- Plots folder not found in workspace (silenced)
                return 
            end
            
            -- Use DisplayName if available, otherwise fall back to Name
            local playerDisplayName = Players.LocalPlayer.DisplayName
            local playerName = Players.LocalPlayer.Name
            
            -- Loop through all plots to find OTHER players' plots (not local player's)
            for _, plot in pairs(plots:GetChildren()) do
                if plot:IsA("Model") then
                    local plotSign = plot:FindFirstChild("PlotSign")
                    if plotSign then
                        local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                        if surfaceGui then
                            local frame = surfaceGui:FindFirstChild("Frame")
                            if frame then
                                local textLabel = frame:FindFirstChild("TextLabel")
                                if textLabel then
                                    local fullText = textLabel.Text
                                    -- Extract name from "playername's Base" format and clean it
                                    local ownerName = fullText:match("(.+)'s [Bb]ase")
                                    
                                    -- Check if this is NOT the local player's base (make others transparent)
                                    if ownerName and ownerName ~= playerDisplayName and ownerName ~= playerName then
                                        local decorations = plot:FindFirstChild("Decorations")
                                        if decorations then
                                            -- Function to change part transparency
                                            local function changePartTransparency(part)
                                                if part:IsA("BasePart") then
                                                    if enable then
                                                        -- Store original transparency if not already stored
                                                        if not part:GetAttribute("OriginalTransparency") then
                                                            part:SetAttribute("OriginalTransparency", tostring(part.Transparency))
                                                        end
                                                        -- Make it transparent
                                                        part.Transparency = 0.7
                                                    else
                                                        -- Restore original transparency
                                                        local originalTransparency = part:GetAttribute("OriginalTransparency")
                                                        if originalTransparency then
                                                            part.Transparency = tonumber(originalTransparency) or 0
                                                        end
                                                    end
                                                end
                                            end
                                            
                                            -- Process Side 1, Side 2, and Side 3
                                            for i = 1, 3 do
                                                local side = decorations:FindFirstChild("Side " .. i)
                                                if side then
                                                    for _, child in pairs(side:GetChildren()) do
                                                        -- Case 1: Parts named "structure base home" directly in the side
                                                        if child.Name == "structure base home" then
                                                            changePartTransparency(child)
                                                        -- Case 2: Any parts directly in the side (outside of models)
                                                        elseif child:IsA("BasePart") then
                                                            changePartTransparency(child)
                                                        -- Case 3: Models named "Model" containing parts
                                                        elseif child.Name == "Model" and child:IsA("Model") then
                                                            for _, modelChild in pairs(child:GetChildren()) do
                                                                changePartTransparency(modelChild)
                                                            end
                                                        -- Case 4: Folder named "Folder" in Side 2 containing parts
                                                        elseif child.Name == "Folder" and child:IsA("Folder") and i == 2 then
                                                            for _, folderChild in pairs(child:GetChildren()) do
                                                                -- Check if it's a direct part
                                                                if folderChild:IsA("BasePart") then
                                                                    changePartTransparency(folderChild)
                                                                -- Check if it's a model named "Side 2" containing parts
                                                                elseif folderChild.Name == "Side 2" and folderChild:IsA("Model") then
                                                                    for _, modelChild in pairs(folderChild:GetChildren()) do
                                                                        changePartTransparency(modelChild)
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            
                                            -- Process parts directly in Decorations (outside of Side models)
                                            for _, child in pairs(decorations:GetChildren()) do
                                                -- Case 1: Parts named "structure base home" directly in decorations
                                                if child.Name == "structure base home" then
                                                    changePartTransparency(child)
                                                -- Case 2: Any parts directly in decorations (outside of Side models)
                                                elseif child:IsA("BasePart") then
                                                    changePartTransparency(child)
                                                -- Case 3: Models named "Model" containing parts (outside of Side models)
                                                elseif child.Name == "Model" and child:IsA("Model") then
                                                    for _, modelChild in pairs(child:GetChildren()) do
                                                        changePartTransparency(modelChild)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        
        toggleTransparentBases(state)
        saveSettings(settings)
    end)
    addTooltip(transparentBasesToggle, "Makes other players' plot bases transparent")

    local rainbowNameToggle = createModernToggle(modulesContent, "Rainbow Name", settings.rainbowName, function(state)
        settings.rainbowName = state
        
        -- Show notification
        showModuleNotification("Rainbow Name", state)
        
        if not state then
            -- Remove rainbow from all plot signs when disabled
            local plots = workspace:FindFirstChild("Plots")
            if plots then
                for _, plot in pairs(plots:GetChildren()) do
                    if plot:IsA("Model") then
                        local plotSign = plot:FindFirstChild("PlotSign")
                        if plotSign then
                            local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                            if surfaceGui then
                                local frame = surfaceGui:FindFirstChild("Frame")
                                if frame then
                                    local textLabel = frame:FindFirstChild("TextLabel")
                                    if textLabel then
                                        local gradient = textLabel:FindFirstChild("RainbowGradient")
                                        if gradient then gradient:Destroy() end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        saveSettings(settings)
    end)
    addTooltip(rainbowNameToggle, "Animates your plot sign name with rainbow colors")

    local highlightHighestToggle = createModernToggle(modulesContent, "Highlight Highest", settings.highlightHighest, function(state)
        settings.highlightHighest = state
        
        -- Show notification
        showModuleNotification("Highlight Highest", state)
        
        if not state then
            -- Clear all highlights when disabled
            local plots = workspace:FindFirstChild("Plots")
            if plots then
                -- Remove from all plots (including direct plot children)
                for _, plot in pairs(plots:GetChildren()) do
                    if plot:IsA("Model") then
                        -- Remove from direct plot children
                        for _, child in pairs(plot:GetChildren()) do
                            if child:IsA("Model") then
                                local highlight = child:FindFirstChild("HighestValueHighlight")
                                if highlight then highlight:Destroy() end
                                
                                local display = child:FindFirstChild("MoneyDisplay")
                                if display then display:Destroy() end
                                
                                local nameDisplay = child:FindFirstChild("NameDisplay")
                                if nameDisplay then nameDisplay:Destroy() end
                                
                                local distanceDisplay = child:FindFirstChild("DistanceDisplay")
                                if distanceDisplay then distanceDisplay:Destroy() end
                            end
                        end
                    end
                end
            end
            
        -- Highlight Highest disabled - logs removed
        end
        saveSettings(settings)
    end)
    addTooltip(highlightHighestToggle, "Highlights the plot with the highest value brainrot")

    local timeToggle = createModernToggle(modulesContent, "Time", settings.time, function(state)
        settings.time = state
        
        -- Show notification
        showModuleNotification("Time", state)
        
        if not state then
            -- Restore all time displays when disabled
            local plots = workspace:FindFirstChild("Plots")
            if plots then
                for _, plot in pairs(plots:GetChildren()) do
                    if plot:IsA("Model") then
                        local purchases = plot:FindFirstChild("Purchases")
                        if purchases then
                            local plotBlock = purchases:FindFirstChild("PlotBlock")
                            if plotBlock then
                                local main = plotBlock:FindFirstChild("Main")
                                if main then
                                    local billboardGui = main:FindFirstChild("BillboardGui")
                                    if billboardGui then
                                        -- Restore original values
                                        local originalSize = billboardGui:GetAttribute("OriginalSize")
                                        if originalSize then
                                            local x, y = originalSize:match("([^,]+),([^,]+)")
                                            billboardGui.Size = UDim2.new(tonumber(x), 0, tonumber(y), 0)
                                        end
                                        
                                        local originalOffset = billboardGui:GetAttribute("OriginalStudsOffset")
                                        if originalOffset then
                                            local x, y, z = originalOffset:match("([^,]+),([^,]+),([^,]+)")
                                            billboardGui.StudsOffset = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                                        end
                                        
                                        -- Restore text sizes
                                        for _, child in pairs(billboardGui:GetChildren()) do
                                            if child:IsA("TextLabel") then
                                                local originalTextSize = child:GetAttribute("OriginalTextSize")
                                                if originalTextSize then
                                                    child.TextSize = tonumber(originalTextSize)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        -- Time display restored - logs removed
        end
        saveSettings(settings)
    end)
    addTooltip(timeToggle, "Displays time information on plot signs")

    -- RADAR TAB CONTENT
    local radarControls = Instance.new("Frame")
    radarControls.Name = "RadarControls"
    radarControls.Size = UDim2.new(1, 0, 0, 120)
    radarControls.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    radarControls.BorderSizePixel = 0
    radarControls.LayoutOrder = 1
    radarControls.ClipsDescendants = true
    radarControls.Parent = radarContent

    local radarControlsCorner = Instance.new("UICorner")
    radarControlsCorner.CornerRadius = UDim.new(0, 8)
    radarControlsCorner.Parent = radarControls

    local radarActive = settings.radarActive == true
    local radarState = {
        startTime = radarActive and os.time() or nil -- Track when radar was turned on
    }
    local radarButton = Instance.new("TextButton")
    radarButton.Size = UDim2.new(0, 140, 0, 40)
    radarButton.Position = UDim2.new(0, 15, 0, 20)
    radarButton.BackgroundColor3 = radarActive and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(60, 60, 60)
    radarButton.BorderSizePixel = 0
    radarButton.Text = radarActive and "STOP RADAR" or "START RADAR"
    radarButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    radarButton.TextSize = 13
    radarButton.Font = Enum.Font.GothamBold
    radarButton.AutoButtonColor = false
    radarButton.Parent = radarControls

    local radarButtonCorner = Instance.new("UICorner")
    radarButtonCorner.CornerRadius = UDim.new(0, 8)
    radarButtonCorner.Parent = radarButton
    
    local radarButtonStroke = Instance.new("UIStroke")
    radarButtonStroke.Color = radarActive and Color3.fromRGB(255, 120, 120) or Color3.fromRGB(80, 80, 80)
    radarButtonStroke.Thickness = 1
    radarButtonStroke.Transparency = 0.3
    radarButtonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    radarButtonStroke.Parent = radarButton
    
    -- Hover and click effects
    radarButton.MouseEnter:Connect(function()
        TweenService:Create(radarButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            BackgroundColor3 = radarActive and Color3.fromRGB(255, 120, 120) or Color3.fromRGB(70, 70, 70),
            Size = UDim2.new(0, 142, 0, 41)
        }):Play()
    end)
    
    radarButton.MouseLeave:Connect(function()
        TweenService:Create(radarButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            BackgroundColor3 = radarActive and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(60, 60, 60),
            Size = UDim2.new(0, 140, 0, 40)
        }):Play()
    end)
    
    radarButton.MouseButton1Down:Connect(function()
        TweenService:Create(radarButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 138, 0, 39)
        }):Play()
    end)
    
    radarButton.MouseButton1Up:Connect(function()
        TweenService:Create(radarButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 142, 0, 41)
        }):Play()
    end)

    radarButton.MouseButton1Click:Connect(function()
        radarActive = not radarActive
        settings.radarActive = radarActive
        saveSettings(settings)
        radarButton.Text = radarActive and "STOP RADAR" or "START RADAR"
        radarButton.BackgroundColor3 = radarActive and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(60, 60, 60)
        radarButtonStroke.Color = radarActive and Color3.fromRGB(255, 120, 120) or Color3.fromRGB(80, 80, 80)
        
        -- Track when radar was turned on for "List Before" functionality
        if radarActive then
            radarState.startTime = os.time()
        else
            radarState.startTime = nil
        end
        
        -- When toggling Radar, refresh the list if we're on the Radar tab
        if activeTab == "radar" and updateRadarDisplay then
            updateRadarDisplay()
        end
    end)

    local clearButton = Instance.new("TextButton")
    clearButton.Size = UDim2.new(0, 140, 0, 40)
    clearButton.Position = UDim2.new(0, 165, 0, 20)
    clearButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    clearButton.BorderSizePixel = 0
    clearButton.Text = "CLEAR ALL"
    clearButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    clearButton.TextSize = 13
    clearButton.Font = Enum.Font.GothamBold
    clearButton.AutoButtonColor = false
    clearButton.Parent = radarControls

    local clearButtonCorner = Instance.new("UICorner")
    clearButtonCorner.CornerRadius = UDim.new(0, 8)
    clearButtonCorner.Parent = clearButton
    
    local clearButtonStroke = Instance.new("UIStroke")
    clearButtonStroke.Color = Color3.fromRGB(70, 70, 70)
    clearButtonStroke.Thickness = 1
    clearButtonStroke.Transparency = 0.3
    clearButtonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    clearButtonStroke.Parent = clearButton
    
    -- Hover and click effects
    clearButton.MouseEnter:Connect(function()
        TweenService:Create(clearButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            BackgroundColor3 = Color3.fromRGB(55, 55, 55),
            Size = UDim2.new(0, 142, 0, 41)
        }):Play()
    end)
    
    clearButton.MouseLeave:Connect(function()
        TweenService:Create(clearButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            BackgroundColor3 = Color3.fromRGB(45, 45, 45),
            Size = UDim2.new(0, 140, 0, 40)
        }):Play()
    end)
    
    clearButton.MouseButton1Down:Connect(function()
        TweenService:Create(clearButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 138, 0, 39)
        }):Play()
    end)
    
    clearButton.MouseButton1Up:Connect(function()
        TweenService:Create(clearButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 142, 0, 41)
        }):Play()
    end)

    clearButton.MouseButton1Click:Connect(function()
        radarData = {}
        updateRadarDisplay()
    end)

    -- Add tooltips to radar buttons
    addTooltip(radarButton, "Toggle radar to detect within range valued brainrots")
    addTooltip(clearButton, "Remove all entries from the radar list")

    -- Edit button to toggle Radar Settings panel
    local editButton = Instance.new("TextButton")
    editButton.Size = UDim2.new(0, 140, 0, 35)
    editButton.Position = UDim2.new(0, 15, 0, 70)
    editButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    editButton.BorderSizePixel = 0
    editButton.Text = "RADAR SETTINGS"
    editButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    editButton.TextSize = 12
    editButton.Font = Enum.Font.GothamSemibold
    editButton.AutoButtonColor = false
    editButton.Parent = radarControls

    local editButtonCorner = Instance.new("UICorner")
    editButtonCorner.CornerRadius = UDim.new(0, 8)
    editButtonCorner.Parent = editButton
    
    local editButtonStroke = Instance.new("UIStroke")
    editButtonStroke.Color = Color3.fromRGB(60, 60, 60)
    editButtonStroke.Thickness = 1
    editButtonStroke.Transparency = 0.3
    editButtonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    editButtonStroke.Parent = editButton
    
    -- Hover and click effects
    editButton.MouseEnter:Connect(function()
        TweenService:Create(editButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            BackgroundColor3 = Color3.fromRGB(45, 45, 45),
            Size = UDim2.new(0, 142, 0, 36)
        }):Play()
        TweenService:Create(editButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()
    end)
    
    editButton.MouseLeave:Connect(function()
        TweenService:Create(editButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            BackgroundColor3 = Color3.fromRGB(35, 35, 35),
            Size = UDim2.new(0, 140, 0, 35)
        }):Play()
        TweenService:Create(editButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
            TextColor3 = Color3.fromRGB(200, 200, 200)
        }):Play()
    end)
    
    editButton.MouseButton1Down:Connect(function()
        TweenService:Create(editButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 138, 0, 34)
        }):Play()
    end)
    
    editButton.MouseButton1Up:Connect(function()
        TweenService:Create(editButton, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 142, 0, 36)
        }):Play()
    end)

    -- Radar list
    -- Factory to create settings modal if not already present
    local function showRadarSettingsModal()
        if radarSettingsModal and radarSettingsModal.Parent then
            -- Already open: bring to front
            radarSettingsModal.ZIndex = 100
            return
        end

        -- Modal container - responsive sizing
        local modal = Instance.new("Frame")
        modal.Name = "RadarSettingsModal"
        modal.Size = UDim2.fromScale(0.25, 0.35) -- Scale-based for responsiveness
        modal.Position = UDim2.fromScale(0.5, 0.5)
        modal.AnchorPoint = Vector2.new(0.5, 0.5) -- Center anchor
        modal.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        modal.BorderSizePixel = 0
        modal.ZIndex = 100
        modal.Active = true
        modal.Draggable = false
        modal.Parent = screenGui
        
        -- Size constraints for modal
        local modalSizeConstraint = Instance.new("UISizeConstraint")
        modalSizeConstraint.MinSize = Vector2.new(320, 300) -- Minimum for mobile
        modalSizeConstraint.MaxSize = Vector2.new(400, 380) -- Maximum for large screens
        modalSizeConstraint.Parent = modal

        local mc = Instance.new("UICorner")
        mc.CornerRadius = UDim.new(0, 12)
        mc.Parent = modal

        -- Add glow stroke matching main UI exactly
        local modalGlow = Instance.new("UIStroke")
        modalGlow.Color = Color3.fromRGB(35, 35, 35)
        modalGlow.Thickness = 0.8
        modalGlow.Transparency = 0.5
        modalGlow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        modalGlow.Parent = modal

        -- Title bar matching main UI
        local modalTitleBar = Instance.new("Frame")
        modalTitleBar.Size = UDim2.new(1, 0, 0, 45)
        modalTitleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        modalTitleBar.BorderSizePixel = 0
        modalTitleBar.ZIndex = 101
        modalTitleBar.Parent = modal

        local modalTitleCorner = Instance.new("UICorner")
        modalTitleCorner.CornerRadius = UDim.new(0, 12)
        modalTitleCorner.Parent = modalTitleBar

        -- Fix bottom corners of title bar
        local modalTitleFix = Instance.new("Frame")
        modalTitleFix.Size = UDim2.new(1, 0, 0, 12)
        modalTitleFix.Position = UDim2.new(0, 0, 1, -12)
        modalTitleFix.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        modalTitleFix.BorderSizePixel = 0
        modalTitleFix.ZIndex = 101
        modalTitleFix.Parent = modalTitleBar

        -- Title text with gradient like main UI
        local modalTitle = Instance.new("TextLabel")
        modalTitle.Size = UDim2.new(1, -50, 1, 0)
        modalTitle.Position = UDim2.new(0, 20, 0, 0)
        modalTitle.BackgroundTransparency = 1
        modalTitle.Text = "RADAR | SETTINGS"
        modalTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
        modalTitle.TextSize = 14
        modalTitle.TextXAlignment = Enum.TextXAlignment.Left
        modalTitle.Font = Enum.Font.GothamBold
        modalTitle.ZIndex = 102
        modalTitle.Parent = modalTitleBar

        -- Add gradient to title text matching main UI
        local modalTitleGradient = Instance.new("UIGradient")
        modalTitleGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 100, 100)), -- Red
            ColorSequenceKeypoint.new(1.0, Color3.fromRGB(255, 255, 255))  -- White
        }
        modalTitleGradient.Rotation = 45
        modalTitleGradient.Parent = modalTitle

        -- Close button with hover animation and glow
        local closeBtn = Instance.new("TextButton")
        closeBtn.Name = "CloseButton"
        closeBtn.Size = UDim2.new(0, 30, 0, 30)
        closeBtn.Position = UDim2.new(1, -40, 0, 7.5)
        closeBtn.BackgroundTransparency = 1
        closeBtn.Text = "×"
        closeBtn.TextColor3 = Color3.fromRGB(150, 150, 150)
        closeBtn.TextSize = 18
        closeBtn.Font = Enum.Font.GothamBold
        closeBtn.ZIndex = 102
        closeBtn.Parent = modalTitleBar
        
        -- Add glow effect to close button (darker red, less intense)
        local closeBtnGlow = Instance.new("UIStroke")
        closeBtnGlow.Color = Color3.fromRGB(180, 60, 60)
        closeBtnGlow.Thickness = 0
        closeBtnGlow.Transparency = 0.65
        closeBtnGlow.Parent = closeBtn

        closeBtn.MouseEnter:Connect(function()
            TweenService:Create(closeBtn, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                TextColor3 = Color3.fromRGB(255, 100, 100)
            }):Play()
            TweenService:Create(closeBtnGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                Thickness = 1.2
            }):Play()
        end)

        closeBtn.MouseLeave:Connect(function()
            TweenService:Create(closeBtn, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                TextColor3 = Color3.fromRGB(150, 150, 150)
            }):Play()
            TweenService:Create(closeBtnGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                Thickness = 0
            }):Play()
        end)
        
        closeBtn.MouseButton1Down:Connect(function()
            TweenService:Create(closeBtn, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
                TextSize = 16
            }):Play()
        end)
        
        closeBtn.MouseButton1Up:Connect(function()
            TweenService:Create(closeBtn, TweenInfo.new(0.08, Enum.EasingStyle.Quad), {
                TextSize = 18
            }):Play()
        end)

        -- Dragging from title bar only with red glow effect
        local modalDragging = false
        local modalDragInput = nil
        local modalDragStart = nil
        local modalStartPos = nil

        modalTitleBar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                modalDragging = true
                modalDragInput = input
                modalDragStart = input.Position
                modalStartPos = modal.Position
                
                -- Show red glow when dragging (matching main UI drag color)
                local glowTween = TweenService:Create(
                    modalGlow,
                    TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                    {
                        Color = Color3.fromRGB(90, 40, 50),
                        Transparency = 0.05
                    }
                )
                glowTween:Play()
            end
        end)
        
        -- Use global input service for smooth dragging
        local modalDragConnection
        modalDragConnection = game:GetService("UserInputService").InputChanged:Connect(function(input)
            if modalDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - modalDragStart
                local s = (_G.__AJ_ROOT_SCALE and _G.__AJ_ROOT_SCALE.Scale) or 1
                if s == 0 then s = 1 end
                local dx = delta.X / s
                local dy = delta.Y / s
                modal.Position = UDim2.new(
                    modalStartPos.X.Scale,
                    modalStartPos.X.Offset + dx,
                    modalStartPos.Y.Scale,
                    modalStartPos.Y.Offset + dy
                )
            end
        end)
        
        local modalEndConnection
        modalEndConnection = game:GetService("UserInputService").InputEnded:Connect(function(input)
            if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and input == modalDragInput then
                modalDragging = false
                -- Return to default glow when released
                local glowOutTween = TweenService:Create(
                    modalGlow,
                    TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                    {
                        Color = Color3.fromRGB(35, 35, 35),
                        Transparency = 0.5
                    }
                )
                glowOutTween:Play()
            end
        end)

        -- Inner content with proper padding - BIGGER for checkboxes
        local inner = Instance.new("Frame")
        inner.Size = UDim2.new(1, -40, 1, -85)
        inner.Position = UDim2.new(0, 20, 0, 55)
        inner.BackgroundTransparency = 1
        inner.ZIndex = 101
        inner.Parent = modal

        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 3)
        layout.Parent = inner

        -- Force ZIndex on slider children to ensure visibility
        local function createVisibleSlider(parent, text, min, max, default, suffix, callback)
            local slider = createModernSlider(parent, text, min, max, default, suffix, callback)
            -- Ensure all descendants have proper ZIndex
            for _, child in ipairs(parent:GetDescendants()) do
                if child:IsA("GuiObject") then
                    child.ZIndex = math.max(child.ZIndex or 1, 102)
                end
            end
            return slider
        end

        local minSlider = createVisibleSlider(inner, "Radar Minimum ($M/s)", 0, 9998.0, settings.radarMinMoney, "M/s", function(value)
            settings.radarMinMoney = value
            saveSettings(settings)
            if updateRadarDisplay then updateRadarDisplay() end
            showNotification("Radar Min Updated", string.format("Set to $%.1fM/s", value), 2)
        end)
        addTooltip(minSlider, "Minimum money per second to show on radar (1 = $1M/s)")
        
        local maxSlider = createVisibleSlider(inner, "Radar Maximum ($M/s)", 0, 9999.0, settings.radarMaxMoney, "M/s", function(value)
            settings.radarMaxMoney = value
            saveSettings(settings)
            if updateRadarDisplay then updateRadarDisplay() end
            showNotification("Radar Max Updated", string.format("Set to $%.1fM/s", value), 2)
        end)
        addTooltip(maxSlider, "Maximum money per second to show on radar (10 = $10M/s)")

        -- Divider between sliders and checkboxes
        local divider = Instance.new("Frame")
        divider.Name = "Divider"
        divider.Size = UDim2.new(1, 0, 0, 1)
        divider.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        divider.BorderSizePixel = 0
        divider.BackgroundTransparency = 0.5
        divider.LayoutOrder = 2.5
        divider.ZIndex = 102
        divider.Parent = inner

        -- Checkboxes row
        local checkboxRow = Instance.new("Frame")
        checkboxRow.Name = "CheckboxRow"
        checkboxRow.Size = UDim2.new(1, 0, 0, 30)
        checkboxRow.BackgroundTransparency = 1
        checkboxRow.LayoutOrder = 3
        checkboxRow.Parent = inner

        -- Helper function to create small checkbox with label
        local function createCheckbox(parent, text, defaultState, posX, callback)
            local container = Instance.new("Frame")
            container.Size = UDim2.new(0.48, 0, 1, 0)
            container.Position = UDim2.new(posX, 0, 0, 0)
            container.BackgroundTransparency = 1
            container.ZIndex = 102
            container.Parent = parent

            -- Small checkbox box
            local checkbox = Instance.new("Frame")
            checkbox.Size = UDim2.new(0, 16, 0, 16)
            checkbox.Position = UDim2.new(0, 0, 0.5, -8)
            checkbox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            checkbox.BorderSizePixel = 0
            checkbox.ZIndex = 102
            checkbox.Parent = container

            local checkCorner = Instance.new("UICorner")
            checkCorner.CornerRadius = UDim.new(0, 3)
            checkCorner.Parent = checkbox

            local checkStroke = Instance.new("UIStroke")
            checkStroke.Color = Color3.fromRGB(60, 60, 60)
            checkStroke.Thickness = 0.5
            checkStroke.Transparency = 0.3
            checkStroke.ZIndex = 102
            checkStroke.Parent = checkbox

            -- Checkmark (initially hidden if not checked)
            local checkmark = Instance.new("TextLabel")
            checkmark.Size = UDim2.new(1, 0, 1, 0)
            checkmark.BackgroundTransparency = 1
            checkmark.Text = "✓"
            checkmark.TextColor3 = Color3.fromRGB(255, 100, 100) -- Red accent color
            checkmark.TextSize = 14
            checkmark.Font = Enum.Font.GothamBold
            checkmark.Visible = defaultState
            checkmark.ZIndex = 103
            checkmark.Parent = checkbox

            -- Label text
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, -22, 1, 0)
            label.Position = UDim2.new(0, 22, 0, 0)
            label.BackgroundTransparency = 1
            label.Text = text
            label.TextColor3 = Color3.fromRGB(200, 200, 200)
            label.TextSize = 12
            label.Font = Enum.Font.Gotham
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.ZIndex = 102
            label.Parent = container
            
            -- Subtle text stroke (initially hidden)
            local labelStroke = Instance.new("UIStroke")
            labelStroke.Color = Color3.fromRGB(180, 180, 180)
            labelStroke.Thickness = 0.6
            labelStroke.Transparency = 1
            labelStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            labelStroke.Parent = label

            -- Click button (covers whole container)
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Text = ""
            button.ZIndex = 104
            button.Parent = container
            
            -- Hover animation for label text with stroke
            button.MouseEnter:Connect(function()
                TweenService:Create(label, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                    TextColor3 = Color3.fromRGB(255, 255, 255)
                }):Play()
                TweenService:Create(labelStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                    Transparency = 0.75
                }):Play()
            end)
            
            button.MouseLeave:Connect(function()
                TweenService:Create(label, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                    TextColor3 = Color3.fromRGB(200, 200, 200)
                }):Play()
                TweenService:Create(labelStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
                    Transparency = 1
                }):Play()
            end)

            button.MouseButton1Click:Connect(function()
                checkmark.Visible = not checkmark.Visible
                checkStroke.Color = checkmark.Visible and Color3.fromRGB(100, 100, 100) or Color3.fromRGB(60, 60, 60)
                checkStroke.Transparency = 0.3
                if callback then callback(checkmark.Visible) end
            end)

            return container, checkmark
        end

        -- List Before checkbox (left)
        local listBeforeContainer, listBeforeCheck = createCheckbox(
            checkboxRow,
            "List Before",
            settings.listBeforeEnabled or false,
            0,
            function(checked)
                settings.listBeforeEnabled = checked
                saveSettings(settings)
                showNotification("List Before " .. (checked and "Enabled" or "Disabled"), "Shows entries from past 3 minutes", 2)
            end
        )
        addTooltip(listBeforeContainer, "Show brainrots found in the past 3 minutes, even before radar was turned on")

        -- Color Timers checkbox (right)
        local colorTimersContainer, colorTimersCheck = createCheckbox(
            checkboxRow,
            "Color Timers",
            settings.colorTimersEnabled or false,
            0.52,
            function(checked)
                settings.colorTimersEnabled = checked
                saveSettings(settings)
                showNotification("Color Timers " .. (checked and "Enabled" or "Disabled"), "Green <1m, Yellow <1:45, Grey after", 2)
            end
        )
        addTooltip(colorTimersContainer, "Color code timer text: Green (<1m), Yellow (1-1:45m), Grey (>1:45m)")

        -- Helper text at the bottom (lower position)
        local helpText = Instance.new("TextLabel")
        helpText.Size = UDim2.new(1, 0, 0, 30)
        helpText.Position = UDim2.new(0, 0, 1, -30)
        helpText.BackgroundTransparency = 1
        helpText.Text = "Range: 1 = $1 Million/s  •  10 = $10 Million/s"
        helpText.TextColor3 = Color3.fromRGB(140, 140, 140)
        helpText.TextSize = 11
        helpText.Font = Enum.Font.Gotham
        helpText.TextXAlignment = Enum.TextXAlignment.Center
        helpText.ZIndex = 102
        helpText.Parent = modal

        -- Close handlers
        local function closeModal()
            if modalDragConnection then modalDragConnection:Disconnect() end
            if modalEndConnection then modalEndConnection:Disconnect() end
            if modal and modal.Parent then modal:Destroy() end
            radarSettingsModal = nil
        end
        closeBtn.MouseButton1Click:Connect(closeModal)

        -- Hide/show with main UI instead of closing
        local visibleConn
        visibleConn = mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
            if modal and modal.Parent then
                modal.Visible = mainFrame.Visible
            end
        end)
        
        -- Only close when screenGui is destroyed
        local ancestryConn
        ancestryConn = screenGui.AncestryChanged:Connect(function()
            if not screenGui.Parent then
                if ancestryConn then ancestryConn:Disconnect() end
                if visibleConn then visibleConn:Disconnect() end
                closeModal()
            end
        end)

        radarSettingsModal = modal
    end

    addTooltip(editButton, "Open radar settings to configure money range and display options")

    editButton.MouseButton1Click:Connect(function()
        -- Toggle: close if already open, otherwise show
        if radarSettingsModal and radarSettingsModal.Parent then
            radarSettingsModal:Destroy()
            radarSettingsModal = nil
        else
            showRadarSettingsModal()
        end
    end)

    local radarListFrame = Instance.new("Frame")
    radarListFrame.Name = "RadarList"
    radarListFrame.Size = UDim2.new(1, 0, 0, 400)
    radarListFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    radarListFrame.BorderSizePixel = 0
    radarListFrame.LayoutOrder = 2
    radarListFrame.Parent = radarContent

    local radarListCorner = Instance.new("UICorner")
    radarListCorner.CornerRadius = UDim.new(0, 8)
    radarListCorner.Parent = radarListFrame

    local radarListTitle = Instance.new("TextLabel")
    radarListTitle.Size = UDim2.new(1, -30, 0, 30)
    radarListTitle.Position = UDim2.new(0, 15, 0, 10)
    radarListTitle.BackgroundTransparency = 1
    radarListTitle.Text = "LIVE DETECTIONS"
    radarListTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    radarListTitle.TextSize = 14
    radarListTitle.TextXAlignment = Enum.TextXAlignment.Left
    radarListTitle.Font = Enum.Font.GothamBold
    radarListTitle.Parent = radarListFrame

    -- Search bar
    local searchFrame = Instance.new("Frame")
    searchFrame.Size = UDim2.new(1, -30, 0, 35)
    searchFrame.Position = UDim2.new(0, 15, 0, 45)
    searchFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    searchFrame.BorderSizePixel = 0
    searchFrame.Parent = radarListFrame

    local searchCorner = Instance.new("UICorner")
    searchCorner.CornerRadius = UDim.new(0, 6)
    searchCorner.Parent = searchFrame

    local searchBox = Instance.new("TextBox")
    searchBox.Size = UDim2.new(1, -20, 1, -10)
    searchBox.Position = UDim2.new(0, 10, 0, 5)
    searchBox.BackgroundTransparency = 1
    searchBox.Text = ""
    searchBox.PlaceholderText = "Search brainrots..."
    searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    searchBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
    searchBox.TextSize = 12
    searchBox.TextXAlignment = Enum.TextXAlignment.Left
    searchBox.Font = Enum.Font.Gotham
    searchBox.Parent = searchFrame

    local radarScrollFrame = Instance.new("ScrollingFrame")
    radarScrollFrame.Size = UDim2.new(1, -30, 1, -90)
    radarScrollFrame.Position = UDim2.new(0, 15, 0, 85)
    radarScrollFrame.BackgroundTransparency = 1
    radarScrollFrame.BorderSizePixel = 0
    radarScrollFrame.ScrollBarThickness = 4
    radarScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(60, 60, 60)
    radarScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    radarScrollFrame.Parent = radarListFrame

    local radarLayout = Instance.new("UIListLayout")
    radarLayout.SortOrder = Enum.SortOrder.LayoutOrder
    radarLayout.Padding = UDim.new(0, 8)
    radarLayout.Parent = radarScrollFrame

    -- Connect search functionality
    searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        if activeTab == "radar" then
            updateRadarDisplay()
        end
    end)

    radarLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        radarScrollFrame.CanvasSize = UDim2.new(0, 0, 0, radarLayout.AbsoluteContentSize.Y + 10)
    end)

    -- Radar entry creation function
    local function createRadarEntry(data)
        local entry = Instance.new("Frame")
        entry.Name = "RadarEntry"
        entry.Size = UDim2.new(1, -10, 0, 55)
        entry.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        entry.BorderSizePixel = 0
        entry.LayoutOrder = #radarScrollFrame:GetChildren()
        entry.Parent = radarScrollFrame
        
        local entryCorner = Instance.new("UICorner")
        entryCorner.CornerRadius = UDim.new(0, 6)
        entryCorner.Parent = entry
        
        -- Hover effect
        local hoverStroke = Instance.new("UIStroke")
        hoverStroke.Color = Color3.fromRGB(60, 60, 60)
        hoverStroke.Thickness = 1
        hoverStroke.Transparency = 1
        hoverStroke.Parent = entry
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(0.6, -10, 0, 20)
        nameLabel.Position = UDim2.new(0, 10, 0, 5)
        nameLabel.BackgroundTransparency = 1
        local displayName = data.displayName or "Unknown"
        local moneyText = data.money or "0.00M$/s"
        nameLabel.Text = displayName .. " - " .. moneyText
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.TextSize = 14
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.Font = Enum.Font.GothamSemibold
        nameLabel.Parent = entry
        
        -- Server info label
        local serverLabel = Instance.new("TextLabel")
        serverLabel.Size = UDim2.new(0.6, -10, 0, 18)
        serverLabel.Position = UDim2.new(0, 10, 0, 25)
        serverLabel.BackgroundTransparency = 1
        local serverId = tostring(data.serverId or "Unknown")
        local serverSnippet = #serverId > 8 and (serverId:sub(1, 8) .. "...") or serverId
        local playerCountText
        if data.playerCount then
            local cap = data.maxPlayers or settings.maxPlayers or game.Players.MaxPlayers
            playerCountText = tostring(data.playerCount) .. "/" .. tostring(cap)
        else
            local currentPlayers = #game.Players:GetPlayers()
            local maxPlayers = game.Players.MaxPlayers
            playerCountText = currentPlayers .. "/" .. maxPlayers
        end
        local ownerText = ""
        if data.owner and data.owner ~= "Unknown" then
            local ownerShort = #data.owner > 3 and (data.owner:sub(1, 3) .. "..") or data.owner
            ownerText = " | Owner: " .. ownerShort
        end
        serverLabel.Text = string.format("Server: %s | %s players%s", serverSnippet, playerCountText, ownerText)
        serverLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        serverLabel.TextSize = 11
        serverLabel.TextXAlignment = Enum.TextXAlignment.Left
        serverLabel.Font = Enum.Font.Gotham
        serverLabel.Parent = entry
        
        local timeLabel = Instance.new("TextLabel")
        timeLabel.Size = UDim2.new(0.3, -10, 0, 20)
        timeLabel.Position = UDim2.new(0.7, 0, 0, 8)
        timeLabel.BackgroundTransparency = 1
        -- Show relative age counter like 12s, 1m 3s
        local function formatAge(sec)
            sec = math.max(0, math.floor(sec))
            if sec < 60 then return tostring(sec).."s" end
            local m = math.floor(sec/60)
            local s = sec % 60
            return string.format("%dm %ds", m, s)
        end
        -- IMPORTANT: firstSeen must be in tick() time, NOT Unix time
        -- data.timestamp is Unix time (os.time()), so we can't use it as fallback
        local firstSeen = data.firstSeen or tick()
        data.firstSeen = firstSeen
        data.lastSeen = data.lastSeen or firstSeen
        local initialAge = tick() - firstSeen
        timeLabel.Text = formatAge(initialAge)
        -- Apply initial color immediately based on settings
        if settings.colorTimersEnabled then
            if initialAge < 60 then
                timeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
            elseif initialAge < 105 then
                timeLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
            else
                timeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
        else
            timeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
        timeLabel.TextSize = 12
        timeLabel.TextXAlignment = Enum.TextXAlignment.Right
        timeLabel.Font = Enum.Font.Gotham
        timeLabel.Parent = entry
        
        -- Found timestamp label (below timer)
        local foundLabel = Instance.new("TextLabel")
        foundLabel.Size = UDim2.new(0.3, -10, 0, 12)
        foundLabel.Position = UDim2.new(0.7, 0, 0, 28)
        foundLabel.BackgroundTransparency = 1
        -- Format the timestamp from data
        local foundTime = "Unknown"
        if data.timestamp then
            -- If we have Unix timestamp, format it as time
            foundTime = os.date("%H:%M:%S", data.timestamp)
        elseif data.foundAt then
            -- If we have ISO timestamp, extract time
            local timeMatch = data.foundAt:match("T(%d+:%d+:%d+)")
            foundTime = timeMatch or "Unknown"
        end
        foundLabel.Text = "Found: " .. foundTime
        foundLabel.TextColor3 = Color3.fromRGB(120, 120, 120)
        foundLabel.TextSize = 9
        foundLabel.TextXAlignment = Enum.TextXAlignment.Right
        foundLabel.Font = Enum.Font.Gotham
        foundLabel.Parent = entry
        
        local infoLabel = Instance.new("TextLabel")
        -- Move below the server line to prevent overlap
        infoLabel.Size = UDim2.new(1, -20, 0, 12)
        infoLabel.Position = UDim2.new(0, 10, 0, 43)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Click to join • Right-click to remove"
        infoLabel.TextColor3 = Color3.fromRGB(120, 120, 120)
        infoLabel.TextSize = 11
        infoLabel.TextXAlignment = Enum.TextXAlignment.Left
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.Parent = entry
        
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(1, 0, 1, 0)
        button.BackgroundTransparency = 1
        button.Text = ""
        button.Parent = entry
        
        -- Add tooltip with money and full owner name
        local moneyText = data.money or (data.value and string.format("$%.2fM/s", data.value / 1e6)) or "Unknown"
        local ownerInfo = ""
        if data.owner and data.owner ~= "Unknown" then
            ownerInfo = " | Owner: " .. data.owner
        end
        addTooltip(entry, moneyText .. ownerInfo)
        
        button.MouseEnter:Connect(function()
            local tween = TweenService:Create(
                hoverStroke,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                {Transparency = 0.5}
            )
            tween:Play()
            entry.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        end)
        
        button.MouseLeave:Connect(function()
            local tween = TweenService:Create(
                hoverStroke,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                {Transparency = 1}
            )
            tween:Play()
            entry.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        end)
        
        button.MouseButton1Click:Connect(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, data.serverId, Players.LocalPlayer)
        end)
        
        button.MouseButton2Click:Connect(function()
            for i, radarEntry in ipairs(radarData) do
                if radarEntry == data then
                    table.remove(radarData, i)
                    break
                end
            end
            entry:Destroy()
        end)
        
        -- live updater for the age label with color coding
        local alive = true
        spawn(function()
            while alive do
                task.wait(1)
                if alive then
                    local age = tick() - (data.firstSeen or tick())
                    timeLabel.Text = formatAge(age)
                    
                    -- Apply color coding if enabled
                    if settings.colorTimersEnabled then
                        if age < 60 then
                            -- Green: less than 1 minute
                            timeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                        elseif age < 105 then
                            -- Yellow: 1 minute to 1:45 (105 seconds)
                            timeLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
                        else
                            -- Grey: after 1:45
                            timeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                        end
                    else
                        -- Default grey if color timers disabled
                        timeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                    end
                end
            end
        end)

        entry.AncestryChanged:Connect(function(_, parent)
            if not parent then alive = false end
        end)

        return entry
    end

    function updateRadarDisplay()
        for _, child in pairs(radarScrollFrame:GetChildren()) do
            if child:IsA("Frame") then
                child:Destroy()
            end
        end
        
        -- Get search term
        local searchTerm = searchBox.Text:lower()
        
        -- Helper to parse money text like "$10.5M/s" to numeric value in dollars per sec
        local function parseMoneyText(txt)
            if type(txt) ~= "string" then return nil end
            local s = txt:lower():gsub("%s+", ""):gsub(",", ""):gsub("/s", ""):gsub("%$", "")
            local mult = 1
            local suf = s:sub(-1)
            if suf == "k" then mult = 1e3; s = s:sub(1, -2) elseif suf == "m" then mult = 1e6; s = s:sub(1, -2) elseif suf == "b" then mult = 1e9; s = s:sub(1, -2) elseif suf == "t" then mult = 1e12; s = s:sub(1, -2) end
            local num = tonumber(s)
            if not num then return nil end
            return num * mult
        end

        local minMoney = (settings.radarMinMoney or 0) * 1e6
        local maxMoney = (settings.radarMaxMoney or 9999) * 1e6
        local function buildSet(listText)
            local set = {}
            if type(listText) == "string" then
                for line in string.gmatch(listText .. "\n", "([^\r\n]+)") do
                    local n = line:lower():gsub("^%s+", ""):gsub("%s+$", "")
                    if n ~= "" then set[n] = true end
                end
            end
            return set
        end
        local whitelistSet = buildSet(settings.whitelistList)

        -- Filter and sort radar data
        -- Use a map to ensure absolute deduplication at display time
        local seenKeys = {}
        local filteredData = {}
        for _, data in ipairs(radarData) do
            local name = (data.displayName or ""):lower()
            if searchTerm == "" or name:find(searchTerm) then
                -- apply money range for display too
                local v = data.value
                if not v and data.money then v = parseMoneyText(data.money) end
                local inRange = true
                if v then inRange = (v >= minMoney and v <= maxMoney) end
                if inRange or whitelistSet[name] then
                    -- FINAL DEDUP: Only add if we haven't seen this uniqueKey yet
                    local key = data.uniqueKey
                    if key and not seenKeys[key] then
                        seenKeys[key] = true
                        table.insert(filteredData, data)
                    end
                end
            end
        end
        
        -- Sort by money value (highest first)
        table.sort(filteredData, function(a, b)
            local aValue = a.value or parseMoneyText(a.money) or 0
            local bValue = b.value or parseMoneyText(b.money) or 0
            return aValue > bValue
        end)
        
        -- Create entries for filtered and sorted data
        for _, data in ipairs(filteredData) do
            createRadarEntry(data)
        end
        
        -- Update canvas size
        local totalHeight = #filteredData * 65 + (#filteredData - 1) * 8
        radarScrollFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight)
    end

    -- Hover effects for buttons
    local function addButtonHoverEffect(button)
        local originalColor = button.BackgroundColor3
        
        button.MouseEnter:Connect(function()
            local tween = TweenService:Create(
                button,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                {BackgroundColor3 = Color3.fromRGB(
                    math.min(originalColor.R * 255 + 20, 255),
                    math.min(originalColor.G * 255 + 20, 255),
                    math.min(originalColor.B * 255 + 20, 255)
                )}
            )
            tween:Play()
        end)
        
        button.MouseLeave:Connect(function()
            local tween = TweenService:Create(
                button,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad),
                {BackgroundColor3 = originalColor}
            )
            tween:Play()
        end)
    end

    addButtonHoverEffect(radarButton)
    addButtonHoverEffect(clearButton)
    addButtonHoverEffect(editButton)

    -- Real-time update system for all features
    local function startRealTimeUpdates()
        spawn(function()
            while true do
                wait(1) -- Update every 1 second for faster timer updates
                
                -- Update Rainbow Name if enabled
                if settings.rainbowName then
                    -- Find richest player and apply rainbow effect
                    local plots = workspace:FindFirstChild("Plots")
                    if plots then
                        local localPlayerName = Players.LocalPlayer.Name
                        local playerValues = {}
                        
                        -- Function to parse price string
                        local function parsePrice(priceStr)
                            if not priceStr then return 0 end
                            local cleanPrice = priceStr:gsub("^%$", ""):gsub("/s$", "")
                            local multiplier = 1
                            if cleanPrice:find("K$") then
                                multiplier = 1000
                                cleanPrice = cleanPrice:gsub("K$", "")
                            elseif cleanPrice:find("M$") then
                                multiplier = 1000000
                                cleanPrice = cleanPrice:gsub("M$", "")
                            elseif cleanPrice:find("B$") then
                                multiplier = 1000000000
                                cleanPrice = cleanPrice:gsub("B$", "")
                            end
                            local numValue = tonumber(cleanPrice)
                            return numValue and (numValue * multiplier) or 0
                        end
                        
                        -- Function to get plot owner
                        local function getPlotOwner(plot)
                            local plotSign = plot:FindFirstChild("PlotSign")
                            if plotSign then
                                local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                if surfaceGui then
                                    local frame = surfaceGui:FindFirstChild("Frame")
                                    if frame then
                                        local textLabel = frame:FindFirstChild("TextLabel")
                                        if textLabel then
                                            local fullText = textLabel.Text
                                            -- Extract name from "playername's Base" format and clean it
                                            local ownerName = fullText:match("(.+)'s [Bb]ase")
                                            
                                            return ownerName, textLabel
                                        end
                                    end
                                end
                            end
                            return nil, nil
                        end
                        
                        -- Scan all plots
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local ownerName, textLabel = getPlotOwner(plot)
                                if ownerName and ownerName ~= localPlayerName then
                                    if not playerValues[ownerName] then
                                        playerValues[ownerName] = {totalValue = 0, textLabel = textLabel}
                                    end
                                    
                                    local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                                    if animalPodiums then
                                        for i = 1, 28 do
                                            local podium = animalPodiums:FindFirstChild(tostring(i))
                                            if podium then
                                                local base = podium:FindFirstChild("Base")
                                                if base then
                                                    local spawn = base:FindFirstChild("Spawn")
                                                    if spawn then
                                                        local attachment = spawn:FindFirstChild("Attachment")
                                                        if attachment then
                                                            local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                                            if animalOverhead then
                                                                local generationLabel = animalOverhead:FindFirstChild("Generation")
                                                                if generationLabel then
                                                                    local value = parsePrice(generationLabel.Text)
                                                                    playerValues[ownerName].totalValue = playerValues[ownerName].totalValue + value
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Find richest player and apply rainbow
                        local richestPlayer = nil
                        local highestValue = 0
                        local richestTextLabel = nil
                        
                        for playerName, data in pairs(playerValues) do
                            if data.totalValue > highestValue then
                                highestValue = data.totalValue
                                richestPlayer = playerName
                                richestTextLabel = data.textLabel
                            end
                        end
                        
                        -- Remove rainbow from all first
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local _, textLabel = getPlotOwner(plot)
                                if textLabel then
                                    local gradient = textLabel:FindFirstChild("RainbowGradient")
                                    if gradient then gradient:Destroy() end
                                end
                            end
                        end
                        
                        -- Apply rainbow to richest
                        if richestTextLabel and richestPlayer then
                            local gradient = Instance.new("UIGradient")
                            gradient.Name = "RainbowGradient"
                            gradient.Color = ColorSequence.new{
                                ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 0, 0)),
                                ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 165, 0)),
                                ColorSequenceKeypoint.new(0.33, Color3.fromRGB(255, 255, 0)),
                                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)),
                                ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 0, 255)),
                                ColorSequenceKeypoint.new(0.83, Color3.fromRGB(75, 0, 130)),
                                ColorSequenceKeypoint.new(1.0, Color3.fromRGB(148, 0, 211))
                            }
                            gradient.Parent = richestTextLabel
                            
                            local tween = TweenService:Create(
                                gradient,
                                TweenInfo.new(2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1),
                                {Rotation = 360}
                            )
                            tween:Play()
                        end
                    end
                end
                
                -- Update Black Base if enabled (with proper toggle support)
                local plots = workspace:FindFirstChild("Plots")
                if plots then
                    -- Use DisplayName if available, otherwise fall back to Name
                    local playerDisplayName = Players.LocalPlayer.DisplayName
                    local playerName = Players.LocalPlayer.Name
                    
                    -- Find player's own plot
                    for _, plot in pairs(plots:GetChildren()) do
                        if plot:IsA("Model") then
                            local plotSign = plot:FindFirstChild("PlotSign")
                            if plotSign then
                                local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                if surfaceGui then
                                    local frame = surfaceGui:FindFirstChild("Frame")
                                    if frame then
                                        local textLabel = frame:FindFirstChild("TextLabel")
                                        if textLabel then
                                            local fullText = textLabel.Text
                                            local ownerName = fullText:match("(.+)'s [Bb]ase")
                                            if ownerName == playerDisplayName or ownerName == playerName then
                                                -- This is the player's plot
                                                local decorations = plot:FindFirstChild("Decorations")
                                                if decorations then
                                                    
                                                    local function processPartForBlackBase(part, shouldBeBlack)
                                                        if part:IsA("BasePart") then
                                                            -- Check if this part has a PointLight child - if so, don't change its color
                                                            local hasPointLight = false
                                                            for _, child in pairs(part:GetChildren()) do
                                                                if child:IsA("PointLight") then
                                                                    hasPointLight = true
                                                                    break
                                                                end
                                                            end
                                                            
                                                            -- Only change color if part doesn't have a PointLight
                                                            if not hasPointLight then
                                                                if shouldBeBlack then
                                                                    -- Only change if not already black (prevent flickering)
                                                                    if part.Color ~= Color3.fromRGB(0, 0, 0) then
                                                                        -- Save original color if not already saved
                                                                        if not part:GetAttribute("OriginalColor") then
                                                                            local color = part.Color
                                                                            part:SetAttribute("OriginalColor", color.R .. "," .. color.G .. "," .. color.B)
                                                                        end
                                                                        part.Color = Color3.fromRGB(0, 0, 0)
                                                                    end
                                                                else
                                                                    -- Only restore if currently black and has saved color
                                                                    local originalColor = part:GetAttribute("OriginalColor")
                                                                    if originalColor and part.Color == Color3.fromRGB(0, 0, 0) then
                                                                        local r, g, b = originalColor:match("([^,]+),([^,]+),([^,]+)")
                                                                        if r and g and b then
                                                                            part.Color = Color3.fromRGB(tonumber(r) * 255, tonumber(g) * 255, tonumber(b) * 255)
                                                                        end
                                                                        part:SetAttribute("OriginalColor", nil)
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                    
                                                    local function processDecorations(parent, shouldBeBlack)
                                                        for _, child in pairs(parent:GetChildren()) do
                                                            processPartForBlackBase(child, shouldBeBlack)
                                                            if child:IsA("Model") or child:IsA("Folder") then
                                                                processDecorations(child, shouldBeBlack)
                                                            end
                                                        end
                                                    end
                                                    
                                                    -- Apply or remove black base based on setting
                                                    processDecorations(decorations, settings.blackBase)
                                                end
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Update Transparent Bases if enabled
                if settings.transparentBases then
                    local plots = workspace:FindFirstChild("Plots")
                    if plots then
                        -- Use DisplayName if available, otherwise fall back to Name
                        local playerDisplayName = Players.LocalPlayer.DisplayName
                        local playerName = Players.LocalPlayer.Name
                        
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local plotSign = plot:FindFirstChild("PlotSign")
                                if plotSign then
                                    local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                    if surfaceGui then
                                        local frame = surfaceGui:FindFirstChild("Frame")
                                        if frame then
                                            local textLabel = frame:FindFirstChild("TextLabel")
                                            if textLabel then
                                                local fullText = textLabel.Text
                                                local ownerName = fullText:match("(.+)'s [Bb]ase")
                                                
                                                -- Check if this is NOT the local player's base
                                                if ownerName and ownerName ~= playerDisplayName and ownerName ~= playerName then
                                                    local decorations = plot:FindFirstChild("Decorations")
                                                    if decorations then
                                                        local function makePartTransparent(part)
                                                            if part:IsA("BasePart") then
                                                                if not part:GetAttribute("OriginalTransparency") then
                                                                    part:SetAttribute("OriginalTransparency", tostring(part.Transparency))
                                                                end
                                                                part.Transparency = 0.7
                                                            end
                                                        end
                                                        
                                                        -- Process all parts in the decoration structure
                                                        for i = 1, 3 do
                                                            local side = decorations:FindFirstChild("Side " .. i)
                                                            if side then
                                                                for _, child in pairs(side:GetChildren()) do
                                                                    if child.Name == "structure base home" then
                                                                        makePartTransparent(child)
                                                                    elseif child:IsA("BasePart") then
                                                                        makePartTransparent(child)
                                                                    elseif child.Name == "Model" and child:IsA("Model") then
                                                                        for _, modelChild in pairs(child:GetChildren()) do
                                                                            makePartTransparent(modelChild)
                                                                        end
                                                                    elseif child.Name == "Folder" and child:IsA("Folder") and i == 2 then
                                                                        for _, folderChild in pairs(child:GetChildren()) do
                                                                            if folderChild:IsA("BasePart") then
                                                                                makePartTransparent(folderChild)
                                                                            elseif folderChild.Name == "Side 2" and folderChild:IsA("Model") then
                                                                                for _, modelChild in pairs(folderChild:GetChildren()) do
                                                                                    makePartTransparent(modelChild)
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        
                                                        -- Process parts directly in Decorations
                                                        for _, child in pairs(decorations:GetChildren()) do
                                                            if child.Name == "structure base home" then
                                                                makePartTransparent(child)
                                                            elseif child:IsA("BasePart") then
                                                                makePartTransparent(child)
                                                            elseif child.Name == "Model" and child:IsA("Model") then
                                                                for _, modelChild in pairs(child:GetChildren()) do
                                                                    makePartTransparent(modelChild)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Update Time Display if enabled
                if settings.time then
                    local plots = workspace:FindFirstChild("Plots")
                    if plots then
                        local localPlayerName = Players.LocalPlayer.Name
                        local playerValues = {}
                        local richestPlot = nil
                        
                        -- Function to parse price string (same as others)
                        local function parsePrice(priceStr)
                            if not priceStr then return 0 end
                            local cleanPrice = priceStr:gsub("^%$", ""):gsub("/s$", "")
                            local multiplier = 1
                            if cleanPrice:find("K$") then
                                multiplier = 1000
                                cleanPrice = cleanPrice:gsub("K$", "")
                            elseif cleanPrice:find("M$") then
                                multiplier = 1000000
                                cleanPrice = cleanPrice:gsub("M$", "")
                            elseif cleanPrice:find("B$") then
                                multiplier = 1000000000
                                cleanPrice = cleanPrice:gsub("B$", "")
                            end
                            local numValue = tonumber(cleanPrice)
                            return numValue and (numValue * multiplier) or 0
                        end
                        
                        -- Function to get plot owner
                        local function getPlotOwner(plot)
                            local plotSign = plot:FindFirstChild("PlotSign")
                            if plotSign then
                                local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                if surfaceGui then
                                    local frame = surfaceGui:FindFirstChild("Frame")
                                    if frame then
                                        local textLabel = frame:FindFirstChild("TextLabel")
                                        if textLabel then
                                            local fullText = textLabel.Text
                                            local ownerName = fullText:match("(.+)'s [Bb]ase")
                                            return ownerName
                                        end
                                    end
                                end
                            end
                            return nil
                        end
                        
                        -- Find richest player's plot
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local ownerName = getPlotOwner(plot)
                                if ownerName and ownerName ~= localPlayerName then
                                    if not playerValues[ownerName] then
                                        playerValues[ownerName] = {totalValue = 0, plot = plot}
                                    end
                                    
                                    local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                                    if animalPodiums then
                                        for i = 1, 28 do
                                            local podium = animalPodiums:FindFirstChild(tostring(i))
                                            if podium then
                                                local base = podium:FindFirstChild("Base")
                                                if base then
                                                    local spawn = base:FindFirstChild("Spawn")
                                                    if spawn then
                                                        local attachment = spawn:FindFirstChild("Attachment")
                                                        if attachment then
                                                            local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                                            if animalOverhead then
                                                                local generationLabel = animalOverhead:FindFirstChild("Generation")
                                                                local displayNameLabel = animalOverhead:FindFirstChild("DisplayName")
                                                                local mutationsLabel = animalOverhead:FindFirstChild("Mutations")
                                                                
                                                                if generationLabel and displayNameLabel then
                                                                    local value = parsePrice(generationLabel.Text)
                                                                    playerValues[ownerName].totalValue = playerValues[ownerName].totalValue + value
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- First restore all other plots
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") and plot ~= richestPlot then
                                local purchases = plot:FindFirstChild("Purchases")
                                if purchases then
                                    local plotBlock = purchases:FindFirstChild("PlotBlock")
                                    if plotBlock then
                                        local main = plotBlock:FindFirstChild("Main")
                                        if main then
                                            local billboardGui = main:FindFirstChild("BillboardGui")
                                            if billboardGui then
                                                -- Restore to normal size if it was enhanced
                                                local originalSize = billboardGui:GetAttribute("OriginalSize")
                                                if originalSize then
                                                    local x, y = originalSize:match("([^,]+),([^,]+)")
                                                    billboardGui.Size = UDim2.new(tonumber(x), 0, tonumber(y), 0)
                                                end
                                                
                                                local originalOffset = billboardGui:GetAttribute("OriginalStudsOffset")
                                                if originalOffset then
                                                    local x, y, z = originalOffset:match("([^,]+),([^,]+),([^,]+)")
                                                    billboardGui.StudsOffset = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                                                end
                                                
                                                -- Restore text sizes
                                                for _, child in pairs(billboardGui:GetChildren()) do
                                                    if child:IsA("TextLabel") then
                                                        local originalTextSize = child:GetAttribute("OriginalTextSize")
                                                        if originalTextSize then
                                                            child.TextSize = tonumber(originalTextSize)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Enhance the richest player's plot time display
                        if richestPlot then
                            local purchases = richestPlot:FindFirstChild("Purchases")
                            if purchases then
                                local plotBlock = purchases:FindFirstChild("PlotBlock")
                                if plotBlock then
                                    local main = plotBlock:FindFirstChild("Main")
                                    if main then
                                        local billboardGui = main:FindFirstChild("BillboardGui")
                                        if billboardGui then
                                            -- Store original values if not already stored
                                            if not billboardGui:GetAttribute("OriginalSize") then
                                                billboardGui:SetAttribute("OriginalSize", tostring(billboardGui.Size.X.Scale) .. "," .. tostring(billboardGui.Size.Y.Scale))
                                            end
                                            if not billboardGui:GetAttribute("OriginalStudsOffset") then
                                                local offset = billboardGui.StudsOffset
                                                billboardGui:SetAttribute("OriginalStudsOffset", tostring(offset.X) .. "," .. tostring(offset.Y) .. "," .. tostring(offset.Z))
                                            end
                                            
                                            -- Apply enhanced settings
                                            billboardGui.Size = UDim2.new(8, 0, 4, 0)
                                            billboardGui.StudsOffset = Vector3.new(0, 10, 0)
                                            
                                            -- Keep text elements enhanced
                                            for _, child in pairs(billboardGui:GetChildren()) do
                                                if child:IsA("TextLabel") then
                                                    if not child:GetAttribute("OriginalTextSize") then
                                                        child:SetAttribute("OriginalTextSize", tostring(child.TextSize))
                                                    end
                                                    child.TextSize = math.max(child.TextSize, 24)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Update Stats Display (always runs to show live stats)
                do
                    local plots = workspace:FindFirstChild("Plots")
                    if plots and _G.StatsLabels then
                        local localPlayerName = Players.LocalPlayer.Name
                        local highestAnimal = nil
                        local highestValue = 0
                        local ownerName = nil
                        
                        -- Function to parse price string
                        local function parsePrice(priceStr)
                            if not priceStr then return 0 end
                            local cleanPrice = priceStr:gsub("^%$", ""):gsub("/s$", "")
                            local multiplier = 1
                            if cleanPrice:find("K$") then
                                multiplier = 1000
                                cleanPrice = cleanPrice:gsub("K$", "")
                            elseif cleanPrice:find("M$") then
                                multiplier = 1000000
                                cleanPrice = cleanPrice:gsub("M$", "")
                            elseif cleanPrice:find("B$") then
                                multiplier = 1000000000
                                cleanPrice = cleanPrice:gsub("B$", "")
                            end
                            local numValue = tonumber(cleanPrice)
                            return numValue and (numValue * multiplier) or 0
                        end
                        
                        -- Function to get plot owner
                        local function getPlotOwner(plot)
                            local plotSign = plot:FindFirstChild("PlotSign")
                            if plotSign then
                                local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                if surfaceGui then
                                    local frame = surfaceGui:FindFirstChild("Frame")
                                    if frame then
                                        local textLabel = frame:FindFirstChild("TextLabel")
                                        if textLabel then
                                            local fullText = textLabel.Text
                                            local plotOwner = fullText:match("(.+)'s [Bb]ase")
                                            return plotOwner
                                        end
                                    end
                                end
                            end
                            return nil
                        end
                        
                        -- Scan all plots for highest brainrot (excluding local player)
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local plotOwner = getPlotOwner(plot)
                                if plotOwner and plotOwner ~= localPlayerName then
                                    local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                                    if animalPodiums then
                                        for i = 1, 28 do
                                            local podium = animalPodiums:FindFirstChild(tostring(i))
                                            if podium then
                                                local base = podium:FindFirstChild("Base")
                                                if base then
                                                    local spawn = base:FindFirstChild("Spawn")
                                                    if spawn then
                                                        local attachment = spawn:FindFirstChild("Attachment")
                                                        if attachment then
                                                            local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                                            if animalOverhead then
                                                                local generationLabel = animalOverhead:FindFirstChild("Generation")
                                                                local displayNameLabel = animalOverhead:FindFirstChild("DisplayName")
                                                                local mutationsLabel = animalOverhead:FindFirstChild("Mutations")
                                                                
                                                                if generationLabel and displayNameLabel then
                                                                    local value = parsePrice(generationLabel.Text)
                                                                    if value > highestValue then
                                                                        highestValue = value
                                                                        highestAnimal = {
                                                                            name = displayNameLabel.Text,
                                                                            money = generationLabel.Text,
                                                                            mutations = mutationsLabel and mutationsLabel.Text or "None",
                                                                            owner = plotOwner
                                                                        }
                                                                        ownerName = plotOwner
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Get timer from richest player (simplified)
                        local timerText = "Timer: --"
                        
                        -- Find the player with the highest brainrot value (same logic as highlight feature)
                        local localPlayerName = Players.LocalPlayer.Name
                        local playerValues = {}
                        
                        local function parsePrice(priceStr)
                            if not priceStr then return 0 end
                            local cleanPrice = priceStr:gsub("^%$", ""):gsub("/s$", "")
                            local multiplier = 1
                            if cleanPrice:find("K$") then
                                multiplier = 1000
                                cleanPrice = cleanPrice:gsub("K$", "")
                            elseif cleanPrice:find("M$") then
                                multiplier = 1000000
                                cleanPrice = cleanPrice:gsub("M$", "")
                            elseif cleanPrice:find("B$") then
                                multiplier = 1000000000
                                cleanPrice = cleanPrice:gsub("B$", "")
                            end
                            local numValue = tonumber(cleanPrice)
                            return numValue and (numValue * multiplier) or 0
                        end
                        
                        local function getPlotOwner(plot)
                            local plotSign = plot:FindFirstChild("PlotSign")
                            if plotSign then
                                local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                if surfaceGui then
                                    local frame = surfaceGui:FindFirstChild("Frame")
                                    if frame then
                                        local textLabel = frame:FindFirstChild("TextLabel")
                                        if textLabel then
                                            local fullText = textLabel.Text
                                            local ownerName = fullText:match("(.+)'s [Bb]ase")
                                            return ownerName
                                        end
                                    end
                                end
                            end
                            return nil
                        end
                        
                        -- Find all animals and their values
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local plotOwner = getPlotOwner(plot)
                                if plotOwner and plotOwner ~= localPlayerName then
                                    local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                                    if animalPodiums then
                                        for _, podium in pairs(animalPodiums:GetChildren()) do
                                            if podium:IsA("Model") and tonumber(podium.Name) then
                                                local spawn = podium:FindFirstChild("Spawn")
                                                if spawn then
                                                    local attachment = spawn:FindFirstChild("Attachment")
                                                    if attachment then
                                                        local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                                        if animalOverhead then
                                                            local frame = animalOverhead:FindFirstChild("Frame")
                                                            if frame then
                                                                local priceLabel = frame:FindFirstChild("Price")
                                                                if priceLabel then
                                                                    local priceText = priceLabel.Text
                                                                    local value = parsePrice(priceText)
                                                                    if value > 0 then
                                                                        if not playerValues[plotOwner] then
                                                                            playerValues[plotOwner] = {maxValue = 0, plotId = plot.Name}
                                                                        end
                                                                        if value > playerValues[plotOwner].maxValue then
                                                                            playerValues[plotOwner].maxValue = value
                                                                            playerValues[plotOwner].plotId = plot.Name
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Find the richest player
                        local richestPlayerName = nil
                        local richestPlotId = nil
                        local maxValue = 0
                        for playerName, data in pairs(playerValues) do
                            if data.maxValue > maxValue then
                                maxValue = data.maxValue
                                richestPlayerName = playerName
                                richestPlotId = data.plotId
                            end
                        end
                        
                        -- Get timer from the richest player's plot (use existing data)
                        if richestPlotId then
                            local richestPlot = plots:FindFirstChild(richestPlotId)
                            if richestPlot then
                                local purchases = richestPlot:FindFirstChild("Purchases")
                                if purchases then
                                    local plotBlock = purchases:FindFirstChild("PlotBlock")
                                    if plotBlock then
                                        local main = plotBlock:FindFirstChild("Main")
                                        if main then
                                            local billboardGui = main:FindFirstChild("BillboardGui")
                                            if billboardGui then
                                                local remainingTimeLabel = billboardGui:FindFirstChild("RemainingTime")
                                                if remainingTimeLabel and remainingTimeLabel:IsA("TextLabel") then
                                                    -- Display whatever text is in the RemainingTime label
                                                    timerText = "Timer: " .. remainingTimeLabel.Text
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Update stats display
                        if highestAnimal then
                            _G.StatsLabels.highestName.Text = "Highest Brainrot: " .. highestAnimal.name
                            _G.StatsLabels.mutations.Text = "Mutations: " .. highestAnimal.mutations
                            _G.StatsLabels.money.Text = "Money/s: " .. highestAnimal.money
                            _G.StatsLabels.owner.Text = "Owner: " .. highestAnimal.owner
                            _G.StatsLabels.timer.Text = timerText
                            _G.StatsLabels.lastUpdated.Text = "Last Updated: " .. os.date("%H:%M:%S")
                        else
                            _G.StatsLabels.highestName.Text = "Highest Brainrot: None found"
                            _G.StatsLabels.mutations.Text = "Mutations: N/A"
                            _G.StatsLabels.money.Text = "Money/s: N/A"
                            _G.StatsLabels.owner.Text = "Owner: N/A"
                            _G.StatsLabels.timer.Text = timerText
                            _G.StatsLabels.lastUpdated.Text = "Last Updated: " .. os.date("%H:%M:%S")
                        end
                    end
                end
                
                -- Update Highlight Highest if enabled
                if settings.highlightHighest then
                    -- Re-run the highlight highest logic
                    local plots = workspace:FindFirstChild("Plots")
                    if plots then
                        local localPlayerName = Players.LocalPlayer.Name
                        local playerValues = {}
                        local allAnimals = {}
                        
                        -- Same parsing function
                        local function parsePrice(priceStr)
                            if not priceStr then return 0 end
                            local cleanPrice = priceStr:gsub("^%$", ""):gsub("/s$", "")
                            local multiplier = 1
                            if cleanPrice:find("K$") then
                                multiplier = 1000
                                cleanPrice = cleanPrice:gsub("K$", "")
                            elseif cleanPrice:find("M$") then
                                multiplier = 1000000
                                cleanPrice = cleanPrice:gsub("M$", "")
                            elseif cleanPrice:find("B$") then
                                multiplier = 1000000000
                                cleanPrice = cleanPrice:gsub("B$", "")
                            end
                            local numValue = tonumber(cleanPrice)
                            return numValue and (numValue * multiplier) or 0
                        end
                        
                        local function getPlotOwner(plot)
                            local plotSign = plot:FindFirstChild("PlotSign")
                            if plotSign then
                                local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
                                if surfaceGui then
                                    local frame = surfaceGui:FindFirstChild("Frame")
                                    if frame then
                                        local textLabel = frame:FindFirstChild("TextLabel")
                                        if textLabel then
                                            local fullText = textLabel.Text
                                            local ownerName = fullText:match("(.+)'s [Bb]ase")
                                            return ownerName
                                        end
                                    end
                                end
                            end
                            return nil
                        end
                        
                        -- First clear all existing highlights
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                for _, child in pairs(plot:GetChildren()) do
                                    if child:IsA("Model") then
                                        local highlight = child:FindFirstChild("HighestValueHighlight")
                                        if highlight then highlight:Destroy() end
                                        local nameDisplay = child:FindFirstChild("NameDisplay")
                                        if nameDisplay then nameDisplay:Destroy() end
                                        local moneyDisplay = child:FindFirstChild("MoneyDisplay")
                                        if moneyDisplay then moneyDisplay:Destroy() end
                                        local distanceDisplay = child:FindFirstChild("DistanceDisplay")
                                        if distanceDisplay then distanceDisplay:Destroy() end
                                    end
                                end
                            end
                        end
                        
                        -- Find richest player and their highest animal
                        for _, plot in pairs(plots:GetChildren()) do
                            if plot:IsA("Model") then
                                local ownerName = getPlotOwner(plot)
                                if ownerName and ownerName ~= localPlayerName then
                                    if not playerValues[ownerName] then
                                        playerValues[ownerName] = {totalValue = 0, plot = plot}
                                    end
                                    
                                    local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                                    if animalPodiums then
                                        for i = 1, 28 do
                                            local podium = animalPodiums:FindFirstChild(tostring(i))
                                            if podium then
                                                local base = podium:FindFirstChild("Base")
                                                if base then
                                                    local spawn = base:FindFirstChild("Spawn")
                                                    if spawn then
                                                        local attachment = spawn:FindFirstChild("Attachment")
                                                        if attachment then
                                                            local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                                            if animalOverhead then
                                                                local generationLabel = animalOverhead:FindFirstChild("Generation")
                                                                local displayNameLabel = animalOverhead:FindFirstChild("DisplayName")
                                                                if generationLabel and displayNameLabel then
                                                                    local value = parsePrice(generationLabel.Text)
                                                                    local displayName = displayNameLabel.Text
                                                                    
                                                                    playerValues[ownerName].totalValue = playerValues[ownerName].totalValue + value
                                                                    
                                                                    table.insert(allAnimals, {
                                                                        value = value,
                                                                        generationText = generationLabel.Text,
                                                                        displayName = displayName,
                                                                        ownerName = ownerName,
                                                                        plot = plot
                                                                    })
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Find richest player
                        local richestPlayer = nil
                        local highestPlayerValue = 0
                        
                        for playerName, data in pairs(playerValues) do
                            if data.totalValue > highestPlayerValue then
                                highestPlayerValue = data.totalValue
                                richestPlayer = playerName
                            end
                        end
                        
                        if richestPlayer then
                            -- Find highest value animal
                            local highestAnimal = nil
                            local highestValue = 0
                            
                            for _, animalData in pairs(allAnimals) do
                                if animalData.ownerName == richestPlayer and animalData.value > highestValue then
                                    highestValue = animalData.value
                                    highestAnimal = animalData
                                end
                            end
                            
                            if highestAnimal then
                                -- Find and highlight the animal model
                                for _, child in pairs(highestAnimal.plot:GetChildren()) do
                                    if child:IsA("Model") and child.Name == highestAnimal.displayName then
                                        -- Create highlight and displays (same code as before but simplified)
                                        local highlight = Instance.new("Highlight")
                                        highlight.Name = "HighestValueHighlight"
                                        highlight.FillColor = Color3.fromRGB(255, 182, 193)
                                        highlight.OutlineColor = Color3.fromRGB(255, 105, 180)
                                        highlight.FillTransparency = 0.3
                                        highlight.OutlineTransparency = 0
                                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                                        highlight.Parent = child
                                        
                                        local animalCFrame, animalSize = child:GetBoundingBox()
                                        
                                        -- Name display
                                        local nameBillboard = Instance.new("BillboardGui")
                                        nameBillboard.Name = "NameDisplay"
                                        nameBillboard.Size = UDim2.new(12, 0, 3, 0)
                                        nameBillboard.StudsOffset = Vector3.new(0, animalSize.Y/2 + 4, 0)
                                        nameBillboard.AlwaysOnTop = true
                                        nameBillboard.MaxDistance = math.huge -- Always visible at any distance
                                        nameBillboard.Parent = child
                                        
                                        local nameLabel = Instance.new("TextLabel")
                                        nameLabel.Size = UDim2.new(1, 0, 1, 0)
                                        nameLabel.BackgroundTransparency = 1
                                        nameLabel.Text = highestAnimal.displayName
                                        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                                        nameLabel.TextScaled = false -- Use fixed size
                                        nameLabel.TextSize = 24 -- Fixed readable size
                                        nameLabel.Font = Enum.Font.GothamBold
                                        nameLabel.Parent = nameBillboard
                                        
                                        local nameTextStroke = Instance.new("UIStroke")
                                        nameTextStroke.Color = Color3.fromRGB(255, 105, 180)
                                        nameTextStroke.Thickness = 2
                                        nameTextStroke.Parent = nameLabel
                                        
                                        -- Money display
                                        local moneyBillboard = Instance.new("BillboardGui")
                                        moneyBillboard.Name = "MoneyDisplay"
                                        moneyBillboard.Size = UDim2.new(10, 0, 2.5, 0)
                                        moneyBillboard.StudsOffset = Vector3.new(0, animalSize.Y/2 + 1.5, 0)
                                        moneyBillboard.AlwaysOnTop = true
                                        moneyBillboard.MaxDistance = math.huge -- Always visible at any distance
                                        moneyBillboard.Parent = child
                                        
                                        local moneyLabel = Instance.new("TextLabel")
                                        moneyLabel.Size = UDim2.new(1, 0, 1, 0)
                                        moneyLabel.BackgroundTransparency = 1
                                        moneyLabel.Text = highestAnimal.generationText
                                        moneyLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
                                        moneyLabel.TextScaled = false -- Use fixed size
                                        moneyLabel.TextSize = 22 -- Fixed readable size
                                        moneyLabel.Font = Enum.Font.GothamBold
                                        moneyLabel.Parent = moneyBillboard
                                        
                                        local moneyTextStroke = Instance.new("UIStroke")
                                        moneyTextStroke.Color = Color3.fromRGB(0, 0, 0)
                                        moneyTextStroke.Thickness = 2
                                        moneyTextStroke.Parent = moneyLabel
                                        
                                        -- Distance display
                                        local distanceBillboard = Instance.new("BillboardGui")
                                        distanceBillboard.Name = "DistanceDisplay"
                                        distanceBillboard.Size = UDim2.new(8, 0, 2, 0)
                                        distanceBillboard.StudsOffset = Vector3.new(0, -animalSize.Y/2 - 1, 0)
                                        distanceBillboard.AlwaysOnTop = true
                                        distanceBillboard.MaxDistance = math.huge -- Always visible at any distance
                                        distanceBillboard.Parent = child
                                        
                                        local distanceBgFrame = Instance.new("Frame")
                                        distanceBgFrame.Size = UDim2.new(1, 0, 1, 0)
                                        distanceBgFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                                        distanceBgFrame.BackgroundTransparency = 0.4
                                        distanceBgFrame.BorderSizePixel = 0
                                        distanceBgFrame.Parent = distanceBillboard
                                        
                                        local distanceBgCorner = Instance.new("UICorner")
                                        distanceBgCorner.CornerRadius = UDim.new(0, 6)
                                        distanceBgCorner.Parent = distanceBgFrame
                                        
                                        local distanceLabel = Instance.new("TextLabel")
                                        distanceLabel.Size = UDim2.new(1, 0, 1, 0)
                                        distanceLabel.BackgroundTransparency = 1
                                        distanceLabel.Text = "0 studs"
                                        distanceLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                                        distanceLabel.TextScaled = false -- Use fixed size
                                        distanceLabel.TextSize = 18 -- Fixed readable size
                                        distanceLabel.Font = Enum.Font.Gotham
                                        distanceLabel.Parent = distanceBgFrame
                                        
                                        local distanceTextStroke = Instance.new("UIStroke")
                                        distanceTextStroke.Color = Color3.fromRGB(0, 0, 0)
                                        distanceTextStroke.Thickness = 1
                                        distanceTextStroke.Parent = distanceLabel
                                        
                                        -- Distance updating
                                        spawn(function()
                                            while child.Parent and distanceLabel.Parent do
                                                local playerPosition = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                                if playerPosition then
                                                    local distance = (playerPosition.Position - animalCFrame.Position).Magnitude
                                                    distanceLabel.Text = math.floor(distance) .. " studs"
                                                end
                                                wait(0.1)
                                            end
                                        end)
                                        
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
    end

    -- Add settings for the new features
    settings.rainbowName = false
    settings.highlightHighest = false
    settings.timeDisplay = false

    -- JSONBin Relay Integration
    local relayState = {
        lastSignature = nil,
        lastTeleportTick = 0,
        lastServerJoined = nil,
        missingRequestWarned = false
    }

    -- Join Manager: retries joining when full and switches to better targets when found
    local joinManager = {
        desired = nil,           -- { serverId, value, displayName, money, playerCount, maxPlayers }
        nextAttemptAt = 0,
        attempting = false,
        lastNotifiedServerId = nil,
    }

    local function scheduleJoin(candidate)
        if not candidate then return end
        if not settings.autoJoin then return end
        local sid = candidate.serverId
        if not sid or sid == "" or sid == game.JobId then return end
        -- Respect current max player cap if provided
        if candidate.playerCount and candidate.maxPlayers and (candidate.playerCount > (settings.maxPlayers or candidate.maxPlayers)) then
            return
        end
        -- Prefer higher value; if equal or higher and different server, switch as well
        local cur = joinManager.desired
        if (not cur)
            or ((candidate.value or 0) > (cur.value or 0))
            or (sid ~= cur.serverId and (candidate.value or 0) >= (cur.value or 0)) then
            joinManager.desired = {
                serverId = sid,
                value = candidate.value,
                displayName = candidate.displayName,
                money = candidate.money,
                playerCount = candidate.playerCount,
                maxPlayers = candidate.maxPlayers,
            }
            -- Attempt ASAP
            joinManager.nextAttemptAt = 0
        end
    end

    -- Background join attempt loop
    task.spawn(function()
        while true do
            task.wait(0.25)
            if settings.autoJoin and joinManager.desired and (tick() >= joinManager.nextAttemptAt) and (not joinManager.attempting) then
                local t = joinManager.desired
                joinManager.attempting = true
                -- Show banner once per server target; don't spam on retries
                if joinManager.lastNotifiedServerId ~= t.serverId then
                    pcall(function()
                        local moneyText = t.money or ("$" .. string.format("%.2fM/s", (t.value or 0) / 1e6))
                        showFoundServerNotification(t.displayName or "Unknown", moneyText)
                    end)
                    joinManager.lastNotifiedServerId = t.serverId
                    task.wait(0.10)
                end

                local ok, err = pcall(function()
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, t.serverId, Players.LocalPlayer)
                end)
                relayState.lastTeleportTick = tick()
                relayState.lastServerJoined = t.serverId
                joinManager.attempting = false
                -- Short backoff, keep trying even if full; switch automatically if a better target is scheduled
                local backoff = 1.0
                if not ok then
                    local e = tostring(err or "")
                    if e:lower():find("full") or e:lower():find("requested game is full") then
                        backoff = 1.0
                    else
                        backoff = 1.5
                    end
                end
                joinManager.nextAttemptAt = tick() + backoff
            end
        end
    end)

    local function buildNameSet(listText)
        local set = {}
        if typeof(listText) ~= "string" then return set end
        for entry in string.gmatch(listText, "[^,]+") do
            local trimmed = entry:match("^%s*(.-)%s*$")
            if trimmed ~= "" then
                set[trimmed:lower()] = true
            end
        end
        return set
    end

    local function parseRelayValue(raw)
        -- Accept raw numbers directly as a value-per-second
        if typeof(raw) == "number" then
            return raw
        elseif typeof(raw) == "string" then
            -- Normalize and quickly reject common non-money states
            local lower = raw:lower()
            -- If it doesn't explicitly say "/s", it's not a money-per-second string (prevents 1h 34m, READY!, etc.)
            if not string.find(lower, "/s") then
                return 0
            end
            if string.find(lower, "ready") then
                return 0
            end

            -- Strip spaces and commas
            local valueStr = raw:gsub("%s+", ""):gsub(",", "")
            -- Remove any '/s' anywhere in the string
            valueStr = valueStr:gsub("/s", "")
            -- Remove any currency symbols anywhere (handles both $4M and 4M$)
            valueStr = valueStr:gsub("%$", "")

            -- Determine suffix multiplier
            local multiplier = 1
            local lastChar = valueStr:sub(-1)
            local suffix = lastChar:lower()
            if suffix == "k" then
                multiplier = 1e3
                valueStr = valueStr:sub(1, -2)
            elseif suffix == "m" then
                multiplier = 1e6
                valueStr = valueStr:sub(1, -2)
            elseif suffix == "b" then
                multiplier = 1e9
                valueStr = valueStr:sub(1, -2)
            elseif suffix == "t" then
                multiplier = 1e12
                valueStr = valueStr:sub(1, -2)
            end

            -- After cleaning, the remaining must be a number
            local numeric = tonumber(valueStr)
            return numeric and (numeric * multiplier) or 0
        end
        return 0
    end

    local function formatRelayMoney(value)
        if value >= 1e12 then
            return string.format("$%.2fT/s", value / 1e12)
        elseif value >= 1e9 then
            return string.format("$%.2fB/s", value / 1e9)
        elseif value >= 1e6 then
            return string.format("$%.2fM/s", value / 1e6)
        elseif value >= 1e3 then
            return string.format("$%.0fK/s", value / 1e3)
        else
            -- Always include '/s' for consistency
            return "$" .. math.floor(value) .. "/s"
        end
    end

    local function removeRelayEntries()
        for index = #radarData, 1, -1 do
            local entry = radarData[index]
            if entry.source == "relay" then
                -- Remove from both array and map
                if entry.uniqueKey then
                    radarMap[entry.uniqueKey] = nil
                end
                table.remove(radarData, index)
            end
        end
    end

    -- Helper function to generate unique key for deduplication
    -- Normalize all fields to ensure consistent matching
    -- NOTE: We do NOT include serverId in the key, so same pet on different servers = ONE entry
    local function makeRadarKey(source, serverId, plotId, displayName, mutation, generation)
        -- Normalize strings: trim whitespace, lowercase for consistency
        local function normalize(str)
            if not str then return "" end
            str = tostring(str)
            str = str:gsub("^%s+", ""):gsub("%s+$", "") -- trim
            str = str:lower() -- lowercase for case-insensitive matching
            return str
        end
        
        -- Key is based on pet identity ONLY (not server), so duplicates across servers are merged
        return string.format("%s|%s|%s|%s", 
            normalize(source),
            normalize(displayName),
            normalize(mutation),
            normalize(generation)
        )
    end

    local function processRelayRecord(record)
        if typeof(record) ~= "table" then return end
        
        -- Only process relay records when radar is actually ON
        if not radarActive then return end

        local brainrots = record.brainrots
        if typeof(brainrots) ~= "table" then
            removeRelayEntries()
            if activeTab == "radar" then updateRadarDisplay() end
            return
        end

        -- REMOVED signature check - we rely purely on uniqueKey map-based deduplication now
        -- This prevents duplicates even when relay sends slightly different timestamps/metadata

        local ignoreSet = buildNameSet(settings.ignoreList)
        local whitelistSet = buildNameSet(settings.whitelistList)
        local onlySet = settings.enableOnlyJoinList and buildNameSet(settings.onlyJoinList) or nil
        
        -- Use RADAR settings for filtering what appears in radar (not AutoJoiner settings!)
        local minMoney = (settings.radarMinMoney or 0) * 1e6
        local maxMoney = (settings.radarMaxMoney or 9999) * 1e6
        
        -- Use AUTOJOINER settings separately for join decisions
        local ajMinMoney = (settings.minMoney or 0) * 1e6
        local ajMaxMoney = (settings.maxMoney or 9999) * 1e6
        
        local serverId = record.serverId
        local playerCountRaw = record.playerCount
        local playerCount = typeof(playerCountRaw) == "number" and playerCountRaw or tonumber(playerCountRaw)
        local relayMaxPlayersRaw = record.maxPlayers
        local relayMaxPlayers = typeof(relayMaxPlayersRaw) == "number" and relayMaxPlayersRaw or tonumber(relayMaxPlayersRaw) or Players.MaxPlayers

        -- Age gate: ignore records older than 180 seconds (3 minutes)
        local nowUnix = os.time()
        local recUnix = tonumber(record.updatedAtUnix) or tonumber(record.serverTimestampUnix)
        local ageSec = recUnix and (nowUnix - recUnix) or nil
        
        -- If "List Before" is DISABLED, only show entries from when radar was turned on (age must be recent)
        -- If "List Before" is ENABLED, show entries from past 3 minutes even if found before radar was on
        if ageSec and ageSec > 180 then
            -- Too old (more than 3 minutes), clear and exit
            removeRelayEntries()
            if activeTab == "radar" then updateRadarDisplay() end
            return
        end
        
        -- If List Before is disabled, also check if entry is from before radar was enabled
        if not settings.listBeforeEnabled then
            -- Only show entries that appeared AFTER radar was turned on
            -- Skip entries that are older than when we started watching
            if radarState.startTime and recUnix and recUnix < radarState.startTime then
                return
            end
        end

        local candidates = {}

        for _, entry in ipairs(brainrots) do
            local displayName = entry.displayName or entry.name or "Unknown"
            local lowerName = displayName:lower()
            local allow = true

            if onlySet and not onlySet[lowerName] then
                allow = false
            end

            if allow and ignoreSet[lowerName] then
                allow = false
            end

            if allow then
                local numericValue = parseRelayValue(entry.value)
                -- Skip entries with 0 value
                if numericValue <= 0 then
                    allow = false
                end
                local moneyInRange = (numericValue >= minMoney and numericValue <= maxMoney)
                local whitelisted = whitelistSet[lowerName] == true
                if allow and (moneyInRange or whitelisted) then
                    local nowTick = tick()
                    
                    -- Calculate firstSeen based on server timestamp age
                    -- If entry is old (List Before showing it), show actual age, not 0
                    local ageSeconds = ageSec or 0
                    local firstSeenTick = nowTick - ageSeconds
                    
                    local mutation = entry.mutation or "Unknown"
                    local generation = entry.generation or entry.generationText or "Unknown"
                    local plotId = entry.plotId or "Relay"
                    
                    -- Generate unique key for this brainrot (pet identity only, not server)
                    local uniqueKey = makeRadarKey("relay", serverId, plotId, displayName, mutation, generation)
                    
                    -- CRITICAL: Check if this exact pet already exists in our map
                    local existingEntry = radarMap[uniqueKey]
                    
                    -- Build the new/updated entry
                    local radarEntry = {
                        displayName = displayName,
                        mutation = mutation,
                        generation = generation,
                        rarity = entry.rarity or "Unknown",
                        owner = entry.owner or "Unknown",
                        plotId = plotId,
                        value = numericValue,
                        money = formatRelayMoney(numericValue),
                        serverId = serverId,
                        playerCount = playerCount,
                        maxPlayers = relayMaxPlayers,
                        -- Seen timestamps used for age/TTL tracking
                        -- Use timestamp from relay (when originally found), not current time
                        timestamp = entry.timestamp or recUnix or os.time(),
                        firstSeen = existingEntry and existingEntry.firstSeen or firstSeenTick,
                        lastSeen = existingEntry and existingEntry.lastSeen or nowTick,  -- Don't refresh lastSeen for existing entries
                        source = "relay",
                        uniqueKey = uniqueKey
                    }
                    
                    if existingEntry then
                        -- ALREADY EXISTS: Update in-place, DO NOT add new entry
                        for i, it in ipairs(radarData) do
                            if it.uniqueKey == uniqueKey then
                                radarData[i] = radarEntry
                                radarMap[uniqueKey] = radarEntry
                                break
                            end
                        end
                    else
                        -- NEW ENTRY: Add to both array and map
                        table.insert(radarData, radarEntry)
                        radarMap[uniqueKey] = radarEntry
                    end
                    
                    table.insert(candidates, radarEntry)
                end
            end
        end

        -- Prune old relay items by TTL (3 minutes = 180 seconds)
        local ttl = 180
        local nowUnix = os.time()
        local i = 1
        while i <= #radarData do
            local item = radarData[i]
            local remove = false
            if item and item.source == "relay" then
                -- Use timestamp (Unix time when found) for TTL check
                local itemTime = item.timestamp or nowUnix
                local age = nowUnix - itemTime
                if age > ttl then
                    remove = true
                end
            end
            if remove then
                -- Remove from both array and map
                if item.uniqueKey then
                    radarMap[item.uniqueKey] = nil
                end
                table.remove(radarData, i)
            else
                i = i + 1
            end
        end

        -- CRITICAL FIX: After processing, regenerate uniqueKeys for ALL entries and remove duplicates
        -- This fixes old entries that might have wrong/missing uniqueKeys
        local deduped = {}
        local dedupedMap = {}
        for _, item in ipairs(radarData) do
            -- Regenerate uniqueKey to ensure it uses current format
            local freshKey = makeRadarKey(
                item.source or "relay",
                item.serverId or "",
                item.plotId or "",
                item.displayName or "",
                item.mutation or "Unknown",
                item.generation or "Unknown"
            )
            item.uniqueKey = freshKey
            
            -- Only add if we haven't seen this key yet
            if not dedupedMap[freshKey] then
                dedupedMap[freshKey] = true
                table.insert(deduped, item)
            end
        end
        radarData = deduped
        
        -- Rebuild radarMap from the deduplicated array to ensure sync
        radarMap = {}
        for _, item in ipairs(radarData) do
            if item.uniqueKey then
                radarMap[item.uniqueKey] = item
            end
        end

        if activeTab == "radar" then
            updateRadarDisplay()
        end

        if #candidates == 0 then
            return
        end

        if settings.autoJoin == false then
            return
        end

        if not serverId or serverId == "" or serverId == game.JobId then
            return
        end

        if playerCount and playerCount > (settings.maxPlayers or relayMaxPlayers or 8) then
            return
        end

        -- Reduce cooldown to retry same server to avoid skipping when quick updates arrive
        if tick() - relayState.lastTeleportTick < 3 and relayState.lastServerJoined == serverId then
            return
        end

        -- Filter candidates using AUTOJOINER settings
        local validCandidates = {}
        local nowTime = os.time()
        
        for _, candidate in ipairs(candidates) do
            local val = candidate.value or 0
            
            -- Check if in AutoJoiner money range (not radar range)
            local inAutoJoinRange = (val >= ajMinMoney and val <= ajMaxMoney)
            
            -- Timestamp filtering based on joinBefore30 setting
            local foundAfterEnabled = true
            if settings.autoJoinEnabledAt and candidate.timestamp then
                if settings.joinBefore30 then
                    -- Allow items found up to 30s before enabling AutoJoiner
                    foundAfterEnabled = (nowTime - candidate.timestamp) <= 30
                else
                    -- Only join items found AFTER AutoJoiner was enabled (strict mode)
                    foundAfterEnabled = (candidate.timestamp >= settings.autoJoinEnabledAt)
                end
            end
            
            if inAutoJoinRange and foundAfterEnabled then
                table.insert(validCandidates, candidate)
            end
        end
        
        if #validCandidates == 0 then
            -- No valid candidates in AutoJoiner range or all are too old
            return
        end

        table.sort(validCandidates, function(a, b)
            return (a.value or 0) > (b.value or 0)
        end)

        local best = validCandidates[1]
        
        -- Check if auto-join is enabled (redundant check for safety)
        if not settings.autoJoin then
            statusText.Text = "⛔ Auto-Join Disabled"
            statusText.TextColor3 = Color3.fromRGB(255, 150, 100)
            return
        end
        
        statusText.Text = string.format("Joining %s ($%.2fM)", best.displayName, (best.value or 0) / 1e6)
        statusText.TextColor3 = Color3.fromRGB(0, 255, 0)

        -- Hand off to the join manager for retries/switching
        scheduleJoin({
            serverId = serverId,
            value = best.value,
            displayName = best.displayName,
            money = best.money,
            playerCount = playerCount,
            maxPlayers = relayMaxPlayers,
        })
    end

    local function pollJSONBinRelay()
        if not request then
        -- AutoJoiner relay disabled: no HTTP request function available (silenced)
            return
        end

        local success, response = pcall(function()
            return request({
                Url = (RELAY_BASE_URL .. "/brainrots/latest"),
                Method = "GET",
            })
        end)

        if not success then
        -- Relay request failed (silenced)
            return
        end

        if not response or not response.Success then
            if response then
                -- Relay HTTP error (silenced)
            end
            return
        end

        local ok, decoded = pcall(function()
            return HttpService:JSONDecode(response.Body)
        end)

        if not ok then
        -- Relay decode failed (silenced)
            return
        end

        local record = decoded.record or decoded
        processRelayRecord(record)
    end

    task.spawn(function()
        while true do
            -- Poll faster when AutoJoin OR Radar is ON to reduce latency; slower otherwise.
            local baseInterval = RELAY_POLL_INTERVAL
            local fastInterval = 1
            local slowInterval = 5
            local delayTime = (settings.autoJoin or radarActive) and fastInterval or math.max(baseInterval, slowInterval)
            pollJSONBinRelay()
            task.wait(delayTime)
        end
    end)

    -- Auto-cleanup task: Remove expired entries every 10 seconds
    task.spawn(function()
        while true do
            task.wait(10)
            if radarActive and #radarData > 0 then
                local ttl = 180 -- 3 minutes
                local nowUnix = os.time()
                local removed = 0
                local i = 1
                while i <= #radarData do
                    local item = radarData[i]
                    -- Use timestamp (Unix time when found) for TTL check, not lastSeen
                    local itemTime = item.timestamp or item.firstSeen or nowUnix
                    local age = nowUnix - itemTime
                    
                    if age > ttl then
                        -- Remove from both array and map
                        if item.uniqueKey then
                            radarMap[item.uniqueKey] = nil
                        end
                        table.remove(radarData, i)
                        removed = removed + 1
                    else
                        i = i + 1
                    end
                end
                
                -- Update display if we removed anything
                if removed > 0 and activeTab == "radar" then
                    updateRadarDisplay()
                end
            end
        end
    end)

    -- Global API
    _G.AutoJoinerSettings = settings
    _G.AutoJoinerUI = _G.AutoJoinerUI or {}
    local AutoJoinerUI = _G.AutoJoinerUI

    AutoJoinerUI.updateStatus = function(status, color)
        statusText.Text = status
        statusText.TextColor3 = color or Color3.fromRGB(255, 255, 255)
    end

    AutoJoinerUI.updateFound = function(count)
        foundText.Text = "Found: " .. count
    end

    AutoJoinerUI.teleportToServer = function(serverId, data)
        TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId, Players.LocalPlayer)
    end

    AutoJoinerUI.addRadarEntry = function(data)
            if radarActive then
                -- Debug prints removed
                
                -- Parse the money value to check if it's in range
                local function parsePrice(priceStr)
                    if not priceStr or typeof(priceStr) ~= "string" then return 0 end
                    local lower = priceStr:lower()
                    -- Only treat as money if it explicitly includes '/s'
                    if not string.find(lower, "/s") then return 0 end
                    if string.find(lower, "ready") then return 0 end

                    -- Normalize like parseRelayValue
                    local cleanPrice = priceStr:gsub("%s+", ""):gsub(",", "")
                    cleanPrice = cleanPrice:gsub("/s", ""):gsub("%$", "")

                    local multiplier = 1
                    local suffix = cleanPrice:sub(-1):lower()
                    if suffix == "k" then
                        multiplier = 1e3
                        cleanPrice = cleanPrice:sub(1, -2)
                    elseif suffix == "m" then
                        multiplier = 1e6
                        cleanPrice = cleanPrice:sub(1, -2)
                    elseif suffix == "b" then
                        multiplier = 1e9
                        cleanPrice = cleanPrice:sub(1, -2)
                    elseif suffix == "t" then
                        multiplier = 1e12
                        cleanPrice = cleanPrice:sub(1, -2)
                    end
                    local numeric = tonumber(cleanPrice)
                    return numeric and (numeric * multiplier) or 0
                end
                
                -- Get the actual money/s value from the animal's Price label
                local actualMoney = "0.00M$/s"
                if data.plotId then
                    local plots = workspace:FindFirstChild("Plots")
                    if plots then
                        local plot = plots:FindFirstChild(data.plotId)
                        if plot then
                            local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                            if animalPodiums then
                                for _, podium in pairs(animalPodiums:GetChildren()) do
                                    if podium:IsA("Model") and tonumber(podium.Name) then
                                        local spawn = podium:FindFirstChild("Spawn")
                                        if spawn then
                                            local attachment = spawn:FindFirstChild("Attachment")
                                            if attachment then
                                                local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                                if animalOverhead then
                                                    local generationLabel = animalOverhead:FindFirstChild("Generation")
                                                    local displayNameLabel = animalOverhead:FindFirstChild("DisplayName")
                                                    
                                                    -- Try multiple ways to match the animal
                                                    local matches = false
                                                    if data.displayName and displayNameLabel then
                                                        matches = displayNameLabel.Text == data.displayName
                                                    elseif data.name and displayNameLabel then
                                                        matches = displayNameLabel.Text == data.name
                                                    end
                                                    
                                                    if matches and generationLabel then
                                                        actualMoney = generationLabel.Text
                                                        -- Found money log removed
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- If we couldn't find the money from plot search, use the data.value if available
                if actualMoney == "0.00M$/s" and data.value then
                    local value = data.value / 1000000 -- Convert to millions
                    actualMoney = "$" .. string.format("%.2f", value) .. "M/s"
                end
                
                -- Parse the money value
                local moneyValue = parsePrice(actualMoney)
                local radarMinMoney = (settings.radarMinMoney or 0) * 1000000 -- Convert to actual value
                local radarMaxMoney = (settings.radarMaxMoney or 9999) * 1000000 -- Convert to actual value
                
                -- Only add if within range, or always if whitelisted by name
                local nameLower = (data.displayName or data.name or ""):lower()
                local whitelistSet = buildNameSet(settings.whitelistList)
                if (moneyValue >= radarMinMoney and moneyValue <= radarMaxMoney) or whitelistSet[nameLower] then
                    local nowTick = tick()
                    data.timestamp = nowTick
                    data.serverId = game.JobId
                    data.money = actualMoney -- Add actual money/s to display
                    data.source = "local"
                    
                    -- Generate unique key for deduplication
                    local uniqueKey = makeRadarKey("local", game.JobId, data.plotId, data.displayName, data.mutation, data.generation)
                    data.uniqueKey = uniqueKey
                    
                    -- Check map first for fast lookup
                    local existingEntry = radarMap[uniqueKey]
                    
                    if existingEntry then
                        -- Update existing entry, preserve firstSeen
                        data.firstSeen = existingEntry.firstSeen or nowTick
                        data.lastSeen = nowTick
                        
                        -- Find and update in array
                        for i, it in ipairs(radarData) do
                            if it.uniqueKey == uniqueKey then
                                radarData[i] = data
                                break
                            end
                        end
                    else
                        -- Add new entry
                        data.firstSeen = nowTick
                        data.lastSeen = nowTick
                        table.insert(radarData, data)
                    end
                    
                    -- Always update the map
                    radarMap[uniqueKey] = data
                    
                    if activeTab == "radar" then
                        updateRadarDisplay()
                    end
                end
            end
        end

    -- Start the real-time update system
    startRealTimeUpdates()

    print("SNIPER v1 Loaded")
